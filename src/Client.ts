// This file was auto-generated by Fern from our API Definition.

import * as environments from "./environments.js";
import * as core from "./core/index.js";
import { mergeHeaders, mergeOnlyDefinedHeaders } from "./core/headers.js";
import * as Scout from "./api/index.js";
import * as errors from "./errors/index.js";
import * as fs from "fs";
import { Workflows } from "./api/resources/workflows/client/Client.js";
import { Environments } from "./api/resources/environments/client/Client.js";
import { Revisions } from "./api/resources/revisions/client/Client.js";
import { Usage } from "./api/resources/usage/client/Client.js";
import { WorkflowLogs } from "./api/resources/workflowLogs/client/Client.js";
import { Copilots } from "./api/resources/copilots/client/Client.js";
import { Triggers } from "./api/resources/triggers/client/Client.js";
import { Integrations } from "./api/resources/integrations/client/Client.js";
import { Organizations } from "./api/resources/organizations/client/Client.js";
import { Collections } from "./api/resources/collections/client/Client.js";
import { Tables } from "./api/resources/tables/client/Client.js";
import { Documents } from "./api/resources/documents/client/Client.js";
import { Sources } from "./api/resources/sources/client/Client.js";
import { Syncs } from "./api/resources/syncs/client/Client.js";

export declare namespace ScoutClient {
    export interface Options {
        environment?: core.Supplier<environments.ScoutEnvironment | string>;
        /** Specify a custom URL to connect the client to. */
        baseUrl?: core.Supplier<string>;
        apiKey?: core.Supplier<core.BearerToken | undefined>;
        /** Additional headers to include in requests. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
        fetcher?: core.FetchFunction;
    }

    export interface RequestOptions {
        /** The maximum time to wait for a response in seconds. */
        timeoutInSeconds?: number;
        /** The number of times to retry the request. Defaults to 2. */
        maxRetries?: number;
        /** A hook to abort the request. */
        abortSignal?: AbortSignal;
        /** Additional query string parameters to include in the request. */
        queryParams?: Record<string, unknown>;
        /** Additional headers to include in the request. */
        headers?: Record<string, string | core.Supplier<string | null | undefined> | null | undefined>;
    }
}

export class ScoutClient {
    protected readonly _options: ScoutClient.Options;
    protected _workflows: Workflows | undefined;
    protected _environments: Environments | undefined;
    protected _revisions: Revisions | undefined;
    protected _usage: Usage | undefined;
    protected _workflowLogs: WorkflowLogs | undefined;
    protected _copilots: Copilots | undefined;
    protected _triggers: Triggers | undefined;
    protected _integrations: Integrations | undefined;
    protected _organizations: Organizations | undefined;
    protected _collections: Collections | undefined;
    protected _tables: Tables | undefined;
    protected _documents: Documents | undefined;
    protected _sources: Sources | undefined;
    protected _syncs: Syncs | undefined;

    constructor(_options: ScoutClient.Options = {}) {
        this._options = {
            ..._options,
            headers: mergeHeaders(
                {
                    "X-Fern-Language": "JavaScript",
                    "X-Fern-SDK-Name": "scoutos",
                    "X-Fern-SDK-Version": "0.10.6",
                    "User-Agent": "scoutos/0.10.6",
                    "X-Fern-Runtime": core.RUNTIME.type,
                    "X-Fern-Runtime-Version": core.RUNTIME.version,
                },
                _options?.headers,
            ),
        };
    }

    public get workflows(): Workflows {
        return (this._workflows ??= new Workflows(this._options));
    }

    public get environments(): Environments {
        return (this._environments ??= new Environments(this._options));
    }

    public get revisions(): Revisions {
        return (this._revisions ??= new Revisions(this._options));
    }

    public get usage(): Usage {
        return (this._usage ??= new Usage(this._options));
    }

    public get workflowLogs(): WorkflowLogs {
        return (this._workflowLogs ??= new WorkflowLogs(this._options));
    }

    public get copilots(): Copilots {
        return (this._copilots ??= new Copilots(this._options));
    }

    public get triggers(): Triggers {
        return (this._triggers ??= new Triggers(this._options));
    }

    public get integrations(): Integrations {
        return (this._integrations ??= new Integrations(this._options));
    }

    public get organizations(): Organizations {
        return (this._organizations ??= new Organizations(this._options));
    }

    public get collections(): Collections {
        return (this._collections ??= new Collections(this._options));
    }

    public get tables(): Tables {
        return (this._tables ??= new Tables(this._options));
    }

    public get documents(): Documents {
        return (this._documents ??= new Documents(this._options));
    }

    public get sources(): Sources {
        return (this._sources ??= new Sources(this._options));
    }

    public get syncs(): Syncs {
        return (this._syncs ??= new Syncs(this._options));
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.infoHandlerInfoGet()
     */
    public infoHandlerInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesRootGetInfoResponse> {
        return core.HttpResponsePromise.fromPromise(this.__infoHandlerInfoGet(requestOptions));
    }

    private async __infoHandlerInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesRootGetInfoResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesRootGetInfoResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /info.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInfoV2TriggersInfoGet()
     */
    public getInfoV2TriggersInfoGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getInfoV2TriggersInfoGet(requestOptions));
    }

    private async __getInfoV2TriggersInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "v2/triggers/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /v2/triggers/info.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInfoV2IndexInfoGet()
     */
    public getInfoV2IndexInfoGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getInfoV2IndexInfoGet(requestOptions));
    }

    private async __getInfoV2IndexInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "v2/index/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /v2/index/info.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInfoV2WorkflowsInfoGet()
     */
    public getInfoV2WorkflowsInfoGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getInfoV2WorkflowsInfoGet(requestOptions));
    }

    private async __getInfoV2WorkflowsInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "v2/workflows/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /v2/workflows/info.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInfoV2CollectionsInfoGet()
     */
    public getInfoV2CollectionsInfoGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getInfoV2CollectionsInfoGet(requestOptions));
    }

    private async __getInfoV2CollectionsInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "v2/collections/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /v2/collections/info.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.BodyParseFileV2FilesParsePost} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.parseFileV2FilesParsePost({
     *         file: fs.createReadStream("/path/to/your/file"),
     *         return_text: true
     *     })
     */
    public parseFileV2FilesParsePost(
        request: Scout.BodyParseFileV2FilesParsePost,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesCollectionParseFileResponse> {
        return core.HttpResponsePromise.fromPromise(this.__parseFileV2FilesParsePost(request, requestOptions));
    }

    private async __parseFileV2FilesParsePost(
        request: Scout.BodyParseFileV2FilesParsePost,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesCollectionParseFileResponse>> {
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (request.return_text != null) {
            _queryParams["return_text"] = request.return_text.toString();
        }

        const _request = await core.newFormData();
        await _request.appendFile("file", request.file);
        const _maybeEncodedRequest = await _request.getRequest();
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "v2/files/parse",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesCollectionParseFileResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /v2/files/parse.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all integrations for an organization
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getIntegrationsIntegrationsGet()
     */
    public getIntegrationsIntegrationsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.IntegrationWithConnections[]> {
        return core.HttpResponsePromise.fromPromise(this.__getIntegrationsIntegrationsGet(requestOptions));
    }

    private async __getIntegrationsIntegrationsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.IntegrationWithConnections[]>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.IntegrationWithConnections[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /integrations.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a specific integration for an organization by its ID.
     *
     * @param {string} integration_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getIntegrationIntegrationsIntegrationIdGet("integration_id")
     */
    public getIntegrationIntegrationsIntegrationIdGet(
        integration_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.IntegrationWithConnections> {
        return core.HttpResponsePromise.fromPromise(
            this.__getIntegrationIntegrationsIntegrationIdGet(integration_id, requestOptions),
        );
    }

    private async __getIntegrationIntegrationsIntegrationIdGet(
        integration_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.IntegrationWithConnections>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `integrations/${encodeURIComponent(integration_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.IntegrationWithConnections, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /integrations/{integration_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all integrations for an organization
     *
     * @param {string} integration_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getIntegrationConnectionsIntegrationsIntegrationIdConnectionsGet("integration_id")
     */
    public getIntegrationConnectionsIntegrationsIntegrationIdConnectionsGet(
        integration_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.IntegrationConnection[]> {
        return core.HttpResponsePromise.fromPromise(
            this.__getIntegrationConnectionsIntegrationsIntegrationIdConnectionsGet(integration_id, requestOptions),
        );
    }

    private async __getIntegrationConnectionsIntegrationsIntegrationIdConnectionsGet(
        integration_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.IntegrationConnection[]>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `integrations/${encodeURIComponent(integration_id)}/connections`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.IntegrationConnection[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /integrations/{integration_id}/connections.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} integration_id
     * @param {Scout.ConnectIntegrationRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.connectIntegrationIntegrationsIntegrationIdConnectPost("integration_id", {
     *         auth_type: "api_key"
     *     })
     */
    public connectIntegrationIntegrationsIntegrationIdConnectPost(
        integration_id: string,
        request: Scout.ConnectIntegrationRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.CreateIntegrationsResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__connectIntegrationIntegrationsIntegrationIdConnectPost(integration_id, request, requestOptions),
        );
    }

    private async __connectIntegrationIntegrationsIntegrationIdConnectPost(
        integration_id: string,
        request: Scout.ConnectIntegrationRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.CreateIntegrationsResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `integrations/${encodeURIComponent(integration_id)}/connect`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.CreateIntegrationsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling POST /integrations/{integration_id}/connect.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SlackMessageRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleSendMessageIntegrationsSlackSendPost({
     *         channel_id: "channel_id",
     *         text: "text"
     *     })
     */
    public handleSendMessageIntegrationsSlackSendPost(
        request: Scout.SlackMessageRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleSendMessageIntegrationsSlackSendPost(request, requestOptions),
        );
    }

    private async __handleSendMessageIntegrationsSlackSendPost(
        request: Scout.SlackMessageRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/slack/send",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /integrations/slack/send.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SlackReactionRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleAddReactionIntegrationsSlackReactPost({
     *         channel_id: "channel_id",
     *         emoji_name: "emoji_name"
     *     })
     */
    public handleAddReactionIntegrationsSlackReactPost(
        request: Scout.SlackReactionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleAddReactionIntegrationsSlackReactPost(request, requestOptions),
        );
    }

    private async __handleAddReactionIntegrationsSlackReactPost(
        request: Scout.SlackReactionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/slack/react",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /integrations/slack/react.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.HandleGetThreadIntegrationsSlackThreadGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleGetThreadIntegrationsSlackThreadGet({
     *         channel_id: "channel_id",
     *         thread_id: "thread_id",
     *         integration_id: "integration_id"
     *     })
     */
    public handleGetThreadIntegrationsSlackThreadGet(
        request: Scout.HandleGetThreadIntegrationsSlackThreadGetRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleGetThreadIntegrationsSlackThreadGet(request, requestOptions),
        );
    }

    private async __handleGetThreadIntegrationsSlackThreadGet(
        request: Scout.HandleGetThreadIntegrationsSlackThreadGetRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        const { channel_id: channelId, thread_id: threadId, integration_id: integrationId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["channel_id"] = channelId;
        _queryParams["thread_id"] = threadId;
        if (integrationId != null) {
            _queryParams["integration_id"] = integrationId;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/slack/thread",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /integrations/slack/thread.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Handles the request to get Slack team info
     *
     * @param {Scout.HandleGetTeamInfoIntegrationsSlackTeamGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleGetTeamInfoIntegrationsSlackTeamGet({
     *         team_id: "team_id"
     *     })
     */
    public handleGetTeamInfoIntegrationsSlackTeamGet(
        request: Scout.HandleGetTeamInfoIntegrationsSlackTeamGetRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleGetTeamInfoIntegrationsSlackTeamGet(request, requestOptions),
        );
    }

    private async __handleGetTeamInfoIntegrationsSlackTeamGet(
        request: Scout.HandleGetTeamInfoIntegrationsSlackTeamGetRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        const { team_id: teamId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        _queryParams["team_id"] = teamId;
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/slack/team",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /integrations/slack/team.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.HandleListChannelsIntegrationsSlackChannelsGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleListChannelsIntegrationsSlackChannelsGet()
     */
    public handleListChannelsIntegrationsSlackChannelsGet(
        request: Scout.HandleListChannelsIntegrationsSlackChannelsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleListChannelsIntegrationsSlackChannelsGet(request, requestOptions),
        );
    }

    private async __handleListChannelsIntegrationsSlackChannelsGet(
        request: Scout.HandleListChannelsIntegrationsSlackChannelsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        const { team_id: teamId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (teamId != null) {
            if (Array.isArray(teamId)) {
                _queryParams["team_id"] = teamId.map((item) => item);
            } else {
                _queryParams["team_id"] = teamId;
            }
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/slack/channels",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /integrations/slack/channels.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Migrate integration tokens from Neon to Firestore with KMS encryption.
     *
     * This endpoint accepts a list of organization IDs and migrates their Slack and Notion tokens.
     * It fetches tokens from the Neon database and stores them in Firestore,
     * encrypting the tokens using KMS.
     *
     * NOTE: Not a public endpoint - used for internal database migration
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.handleMigrateIntegrationsIntegrationsMigratePost()
     */
    public handleMigrateIntegrationsIntegrationsMigratePost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleMigrateIntegrationsIntegrationsMigratePost(requestOptions),
        );
    }

    private async __handleMigrateIntegrationsIntegrationsMigratePost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/migrate",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /integrations/migrate.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Handle Notion OAuth token upsert
     *
     * Args:
     *     request: The FastAPI request object
     *     body: The request body containing the access token and metadata
     *
     * Returns:
     *     Response indicating success
     *
     * Raises:
     *     HTTPException: If there's an error during the process
     *
     * @param {Scout.NotionOAuthRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleNotionOauthIntegrationsNotionOauthPost({
     *         access_token: "access_token",
     *         metadata: {
     *             "key": "value"
     *         }
     *     })
     */
    public handleNotionOauthIntegrationsNotionOauthPost(
        request: Scout.NotionOAuthRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleNotionOauthIntegrationsNotionOauthPost(request, requestOptions),
        );
    }

    private async __handleNotionOauthIntegrationsNotionOauthPost(
        request: Scout.NotionOAuthRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "integrations/notion/oauth",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /integrations/notion/oauth.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SrcAppHttpRoutesIntegrationMcpExchangeMcpAuthPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.exchangeMcpAuthMcpAuthorizationPost({
     *         code: "code",
     *         state: "state",
     *         url: "url",
     *         name: "name",
     *         integration_id: "integration_id"
     *     })
     */
    public exchangeMcpAuthMcpAuthorizationPost(
        request: Scout.SrcAppHttpRoutesIntegrationMcpExchangeMcpAuthPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__exchangeMcpAuthMcpAuthorizationPost(request, requestOptions),
        );
    }

    private async __exchangeMcpAuthMcpAuthorizationPost(
        request: Scout.SrcAppHttpRoutesIntegrationMcpExchangeMcpAuthPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "mcp/authorization",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /mcp/authorization.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SrcAppHttpRoutesIntegrationMcpConnectMcpPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.connectMcpMcpConnectPost({
     *         url: "url",
     *         name: "name",
     *         integration_id: "integration_id"
     *     })
     */
    public connectMcpMcpConnectPost(
        request: Scout.SrcAppHttpRoutesIntegrationMcpConnectMcpPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__connectMcpMcpConnectPost(request, requestOptions));
    }

    private async __connectMcpMcpConnectPost(
        request: Scout.SrcAppHttpRoutesIntegrationMcpConnectMcpPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "mcp/connect",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /mcp/connect.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} connection_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteMcpConnectionMcpServersConnectionIdDelete("connection_id")
     */
    public deleteMcpConnectionMcpServersConnectionIdDelete(
        connection_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__deleteMcpConnectionMcpServersConnectionIdDelete(connection_id, requestOptions),
        );
    }

    private async __deleteMcpConnectionMcpServersConnectionIdDelete(
        connection_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `mcp/servers/${encodeURIComponent(connection_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling DELETE /mcp/servers/{connection_id}.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getMcpServersMcpServersGet()
     */
    public getMcpServersMcpServersGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getMcpServersMcpServersGet(requestOptions));
    }

    private async __getMcpServersMcpServersGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "mcp/servers",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /mcp/servers.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInfoInboxInfoGet()
     */
    public getInfoInboxInfoGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getInfoInboxInfoGet(requestOptions));
    }

    private async __getInfoInboxInfoGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "inbox/info",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /inbox/info.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Process an interaction request through the environment.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session
     *     interaction_request: The interaction request data
     *
     * Returns:
     *     Span with the results of the interaction attached to its attributes
     *
     * @param {Scout.HandleGetSessionsInboxSessionsGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleGetSessionsInboxSessionsGet({
     *         search: "search"
     *     })
     */
    public handleGetSessionsInboxSessionsGet(
        request: Scout.HandleGetSessionsInboxSessionsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__handleGetSessionsInboxSessionsGet(request, requestOptions));
    }

    private async __handleGetSessionsInboxSessionsGet(
        request: Scout.HandleGetSessionsInboxSessionsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { search } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (search != null) {
            _queryParams["search"] = search;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "inbox/sessions",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /inbox/sessions.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Process an interaction request through the environment.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session
     *     interaction_request: The interaction request data
     *
     * Returns:
     *     Span with the results of the interaction attached to its attributes
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.handleGetNotificationsInboxNotificationsGet()
     */
    public handleGetNotificationsInboxNotificationsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__handleGetNotificationsInboxNotificationsGet(requestOptions));
    }

    private async __handleGetNotificationsInboxNotificationsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "inbox/notifications",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /inbox/notifications.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} session_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleGetSessionByIdInboxSessionIdGet("session_id")
     */
    public handleGetSessionByIdInboxSessionIdGet(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleGetSessionByIdInboxSessionIdGet(session_id, requestOptions),
        );
    }

    private async __handleGetSessionByIdInboxSessionIdGet(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /inbox/{session_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete an inbox session and all its associated messages.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session to delete
     *
     * Returns:
     *     DeleteResponse with deletion status
     *
     * @param {string} session_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleDeleteSessionInboxSessionIdDelete("session_id")
     */
    public handleDeleteSessionInboxSessionIdDelete(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.DeleteResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleDeleteSessionInboxSessionIdDelete(session_id, requestOptions),
        );
    }

    private async __handleDeleteSessionInboxSessionIdDelete(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.DeleteResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.DeleteResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling DELETE /inbox/{session_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} session_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.handleTranscribeInboxSessionIdTranscribePost("session_id")
     */
    public handleTranscribeInboxSessionIdTranscribePost(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleTranscribeInboxSessionIdTranscribePost(session_id, requestOptions),
        );
    }

    private async __handleTranscribeInboxSessionIdTranscribePost(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}/transcribe`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling POST /inbox/{session_id}/transcribe.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} session_id
     * @param {Scout.BodyUploadPrivateFilesInboxSessionIdFilesPost} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.uploadPrivateFilesInboxSessionIdFilesPost("session_id", {
     *         files: [fs.createReadStream("/path/to/your/file")]
     *     })
     */
    public uploadPrivateFilesInboxSessionIdFilesPost(
        session_id: string,
        request: Scout.BodyUploadPrivateFilesInboxSessionIdFilesPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.FilesResponse[]> {
        return core.HttpResponsePromise.fromPromise(
            this.__uploadPrivateFilesInboxSessionIdFilesPost(session_id, request, requestOptions),
        );
    }

    private async __uploadPrivateFilesInboxSessionIdFilesPost(
        session_id: string,
        request: Scout.BodyUploadPrivateFilesInboxSessionIdFilesPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.FilesResponse[]>> {
        const _request = await core.newFormData();
        for (const _file of request.files) {
            await _request.appendFile("files", _file);
        }

        const _maybeEncodedRequest = await _request.getRequest();
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}/files`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.FilesResponse[], rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /inbox/{session_id}/files.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Process an interaction request through the environment.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session
     *     interaction_request: The interaction request data
     *
     * Returns:
     *     Span with the results of the interaction attached to its attributes
     *
     * @param {string} session_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleGetSessionMessagesInboxSessionIdMessagesGet("session_id")
     */
    public handleGetSessionMessagesInboxSessionIdMessagesGet(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleGetSessionMessagesInboxSessionIdMessagesGet(session_id, requestOptions),
        );
    }

    private async __handleGetSessionMessagesInboxSessionIdMessagesGet(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}/messages`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /inbox/{session_id}/messages.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Process an interaction request through the environment.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session
     *     interaction_request: The interaction request data
     *
     * Returns:
     *     Span with the results of the interaction attached to its attributes
     *
     * @param {string} session_id
     * @param {Scout.SrcAppHttpRoutesInboxHandleMessageInteractionRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleMessageInboxSessionIdMessagesPost("session_id", {
     *         messages: [{
     *                 content: "content",
     *                 content_type: "text/plain"
     *             }],
     *         participants: [{
     *                 id: "id"
     *             }]
     *     })
     */
    public handleMessageInboxSessionIdMessagesPost(
        session_id: string,
        request: Scout.SrcAppHttpRoutesInboxHandleMessageInteractionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleMessageInboxSessionIdMessagesPost(session_id, request, requestOptions),
        );
    }

    private async __handleMessageInboxSessionIdMessagesPost(
        session_id: string,
        request: Scout.SrcAppHttpRoutesInboxHandleMessageInteractionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}/messages`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /inbox/{session_id}/messages.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Process an interaction request through the environment.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session
     *     interaction_request: The interaction request data
     *
     * Returns:
     *     Span with the results of the interaction attached to its attributes
     *
     * @param {string} session_id
     * @param {Scout.Participant[]} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handlePostSessionParticipantInboxSessionsSessionIdParticipantsPost("session_id", [{
     *             id: "id",
     *             type: "scout_user"
     *         }])
     */
    public handlePostSessionParticipantInboxSessionsSessionIdParticipantsPost(
        session_id: string,
        request: Scout.Participant[],
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__handlePostSessionParticipantInboxSessionsSessionIdParticipantsPost(
                session_id,
                request,
                requestOptions,
            ),
        );
    }

    private async __handlePostSessionParticipantInboxSessionsSessionIdParticipantsPost(
        session_id: string,
        request: Scout.Participant[],
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/sessions/${encodeURIComponent(session_id)}/participants`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling POST /inbox/sessions/{session_id}/participants.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Cancel ongoing agent response for a session.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session to cancel
     *
     * Returns:
     *     CancelResponse with cancellation status
     *
     * @param {string} session_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleCancelSessionInboxSessionIdCancelPost("session_id")
     */
    public handleCancelSessionInboxSessionIdCancelPost(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.CancelResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleCancelSessionInboxSessionIdCancelPost(session_id, requestOptions),
        );
    }

    private async __handleCancelSessionInboxSessionIdCancelPost(
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.CancelResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}/cancel`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.CancelResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /inbox/{session_id}/cancel.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Rename an inbox session by updating its title.
     *
     * Args:
     *     request: The FastAPI request
     *     session_id: The ID of the session to rename
     *     rename_request: The request containing the new title
     *
     * Returns:
     *     RenameResponse with rename status and new title
     *
     * @param {string} session_id
     * @param {Scout.RenameRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.handleRenameSessionInboxSessionIdRenamePost("session_id", {
     *         title: "title"
     *     })
     */
    public handleRenameSessionInboxSessionIdRenamePost(
        session_id: string,
        request: Scout.RenameRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.RenameResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__handleRenameSessionInboxSessionIdRenamePost(session_id, request, requestOptions),
        );
    }

    private async __handleRenameSessionInboxSessionIdRenamePost(
        session_id: string,
        request: Scout.RenameRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.RenameResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `inbox/${encodeURIComponent(session_id)}/rename`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.RenameResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /inbox/{session_id}/rename.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Execute a hook trigger.
     *
     * This is the main endpoint that external services call to trigger hooks.
     *
     * @param {string} hook_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.executeHookWebhooksHookIdGet("hook_id")
     */
    public executeHookWebhooksHookIdGet(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__executeHookWebhooksHookIdGet(hook_id, requestOptions));
    }

    private async __executeHookWebhooksHookIdGet(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `webhooks/${encodeURIComponent(hook_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /webhooks/{hook_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Execute a hook trigger.
     *
     * This is the main endpoint that external services call to trigger hooks.
     *
     * @param {string} hook_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.executeHookWebhooksHookIdPost("hook_id")
     */
    public executeHookWebhooksHookIdPost(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__executeHookWebhooksHookIdPost(hook_id, requestOptions));
    }

    private async __executeHookWebhooksHookIdPost(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `webhooks/${encodeURIComponent(hook_id)}`,
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /webhooks/{hook_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Soft delete a hook.
     *
     * @param {string} hook_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteHookWebhooksHookIdDelete("hook_id")
     */
    public deleteHookWebhooksHookIdDelete(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.DeleteHookResponse> {
        return core.HttpResponsePromise.fromPromise(this.__deleteHookWebhooksHookIdDelete(hook_id, requestOptions));
    }

    private async __deleteHookWebhooksHookIdDelete(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.DeleteHookResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `webhooks/${encodeURIComponent(hook_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.DeleteHookResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling DELETE /webhooks/{hook_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update a hook's configuration.
     *
     * @param {string} hook_id
     * @param {Scout.HookUpdate} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.updateHookWebhooksHookIdPatch("hook_id")
     */
    public updateHookWebhooksHookIdPatch(
        hook_id: string,
        request: Scout.HookUpdate = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateHookWebhooksHookIdPatch(hook_id, request, requestOptions),
        );
    }

    private async __updateHookWebhooksHookIdPatch(
        hook_id: string,
        request: Scout.HookUpdate = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `webhooks/${encodeURIComponent(hook_id)}`,
            ),
            method: "PATCH",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling PATCH /webhooks/{hook_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List all hooks for the current organization.
     *
     * @param {Scout.ListHooksWebhooksGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.listHooksWebhooksGet({
     *         target_type: "target_type",
     *         target_id: "target_id"
     *     })
     */
    public listHooksWebhooksGet(
        request: Scout.ListHooksWebhooksGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.HooksListResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listHooksWebhooksGet(request, requestOptions));
    }

    private async __listHooksWebhooksGet(
        request: Scout.ListHooksWebhooksGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.HooksListResponse>> {
        const { target_type: targetType, target_id: targetId } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (targetType != null) {
            _queryParams["target_type"] = targetType;
        }

        if (targetId != null) {
            _queryParams["target_id"] = targetId;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "webhooks",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.HooksListResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /webhooks.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new hook for a workflow or other target.
     *
     * @param {Scout.CreateHookWebhooksPostRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.createHookWebhooksPost({
     *         name: "name",
     *         target_id: "target_id",
     *         target_type: "workflow"
     *     })
     */
    public createHookWebhooksPost(
        request: Scout.CreateHookWebhooksPostRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.CreateHookWebhooksPostResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createHookWebhooksPost(request, requestOptions));
    }

    private async __createHookWebhooksPost(
        request: Scout.CreateHookWebhooksPostRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.CreateHookWebhooksPostResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "webhooks",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.CreateHookWebhooksPostResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /webhooks.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a hook by its ID.
     *
     * @param {string} hook_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getHookWebhooksHookIdDetailsGet("hook_id")
     */
    public getHookWebhooksHookIdDetailsGet(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.GetHookWebhooksHookIdDetailsGetResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getHookWebhooksHookIdDetailsGet(hook_id, requestOptions));
    }

    private async __getHookWebhooksHookIdDetailsGet(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.GetHookWebhooksHookIdDetailsGetResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `webhooks/${encodeURIComponent(hook_id)}/details`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.GetHookWebhooksHookIdDetailsGetResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /webhooks/{hook_id}/details.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInfoMoneyGet()
     */
    public getInfoMoneyGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingGetInfoGetInfoResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getInfoMoneyGet(requestOptions));
    }

    private async __getInfoMoneyGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingGetInfoGetInfoResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "money",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingGetInfoGetInfoResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /money.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getBillingAccountsGet()
     */
    public getBillingAccountsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingGetBillingResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getBillingAccountsGet(requestOptions));
    }

    private async __getBillingAccountsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingGetBillingResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "accounts",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingGetBillingResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /accounts.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.GetUsageAccountsUsageGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getUsageAccountsUsageGet({
     *         start_date: "start_date",
     *         end_date: "end_date"
     *     })
     */
    public getUsageAccountsUsageGet(
        request: Scout.GetUsageAccountsUsageGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.Result> {
        return core.HttpResponsePromise.fromPromise(this.__getUsageAccountsUsageGet(request, requestOptions));
    }

    private async __getUsageAccountsUsageGet(
        request: Scout.GetUsageAccountsUsageGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.Result>> {
        const { start_date: startDate, end_date: endDate } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "accounts/usage",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.Result, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /accounts/usage.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getInvoicesAccountsInvoicesGet()
     */
    public getInvoicesAccountsInvoicesGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingGetInvoicesResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getInvoicesAccountsInvoicesGet(requestOptions));
    }

    private async __getInvoicesAccountsInvoicesGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingGetInvoicesResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "accounts/invoices",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingGetInvoicesResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /accounts/invoices.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.createPortalSessionAccountsPortalGet()
     */
    public createPortalSessionAccountsPortalGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingCreatePortalSessionResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createPortalSessionAccountsPortalGet(requestOptions));
    }

    private async __createPortalSessionAccountsPortalGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingCreatePortalSessionResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "accounts/portal",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingCreatePortalSessionResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /accounts/portal.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getWorkflowUsageAccountsUsageWorkflowsGet()
     */
    public getWorkflowUsageAccountsUsageWorkflowsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(this.__getWorkflowUsageAccountsUsageWorkflowsGet(requestOptions));
    }

    private async __getWorkflowUsageAccountsUsageWorkflowsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "accounts/usage/workflows",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /accounts/usage/workflows.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * This endpoint will pull any org facing notifications for the app to display
     * Mostly billing related so far
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getNotificationsNotificationsGet()
     */
    public getNotificationsNotificationsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingGetNotificationsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getNotificationsNotificationsGet(requestOptions));
    }

    private async __getNotificationsNotificationsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingGetNotificationsResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "notifications",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingGetNotificationsResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /notifications.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.Plan} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.changeBillingPlanAccountsPlanPut({
     *         name: "plan_1"
     *     })
     */
    public changeBillingPlanAccountsPlanPut(
        request: Scout.Plan,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingChangeBillingPlanResponse> {
        return core.HttpResponsePromise.fromPromise(this.__changeBillingPlanAccountsPlanPut(request, requestOptions));
    }

    private async __changeBillingPlanAccountsPlanPut(
        request: Scout.Plan,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingChangeBillingPlanResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "accounts/plan",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: { ...request, interval_type: "monthly" },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingChangeBillingPlanResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling PUT /accounts/plan.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.stripeWebhookHooksStripePost()
     */
    public stripeWebhookHooksStripePost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__stripeWebhookHooksStripePost(requestOptions));
    }

    private async __stripeWebhookHooksStripePost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "hooks/stripe",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /hooks/stripe.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.renewPlansCronsRenewPlansPost()
     */
    public renewPlansCronsRenewPlansPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingRenewPlansResponse> {
        return core.HttpResponsePromise.fromPromise(this.__renewPlansCronsRenewPlansPost(requestOptions));
    }

    private async __renewPlansCronsRenewPlansPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingRenewPlansResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "crons/renew_plans",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingRenewPlansResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /crons/renew_plans.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.dailyBillingTasksCronsFreePlanUsagePost()
     */
    public dailyBillingTasksCronsFreePlanUsagePost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingFreePlanUsageResponse> {
        return core.HttpResponsePromise.fromPromise(this.__dailyBillingTasksCronsFreePlanUsagePost(requestOptions));
    }

    private async __dailyBillingTasksCronsFreePlanUsagePost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingFreePlanUsageResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "crons/free_plan_usage",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingFreePlanUsageResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /crons/free_plan_usage.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.billingHourlyCronsBillingHourlyPost()
     */
    public billingHourlyCronsBillingHourlyPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesBillingBillingHourlyResponse> {
        return core.HttpResponsePromise.fromPromise(this.__billingHourlyCronsBillingHourlyPost(requestOptions));
    }

    private async __billingHourlyCronsBillingHourlyPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesBillingBillingHourlyResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "crons/billing_hourly",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesBillingBillingHourlyResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /crons/billing_hourly.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} trace_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.listSpansTracesTraceIdSpansGet("trace_id")
     */
    public listSpansTracesTraceIdSpansGet(
        trace_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__listSpansTracesTraceIdSpansGet(trace_id, requestOptions));
    }

    private async __listSpansTracesTraceIdSpansGet(
        trace_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `traces/${encodeURIComponent(trace_id)}/spans`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /traces/{trace_id}/spans.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List agent sessions for a given agent and date range.
     *
     * Args:
     *     request: The FastAPI request
     *     agent_id: The ID of the agent
     *     start_date: Optional start date for filtering
     *     end_date: Optional end date for filtering
     *
     * Returns:
     *     Response with list of agent sessions
     *
     * @param {string} agent_id
     * @param {Scout.ListAgentSessionsObservabilityAgentsAgentIdSessionsGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.listAgentSessionsObservabilityAgentsAgentIdSessionsGet("agent_id", {
     *         start_date: "2024-01-15T09:30:00Z",
     *         end_date: "2024-01-15T09:30:00Z"
     *     })
     */
    public listAgentSessionsObservabilityAgentsAgentIdSessionsGet(
        agent_id: string,
        request: Scout.ListAgentSessionsObservabilityAgentsAgentIdSessionsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__listAgentSessionsObservabilityAgentsAgentIdSessionsGet(agent_id, request, requestOptions),
        );
    }

    private async __listAgentSessionsObservabilityAgentsAgentIdSessionsGet(
        agent_id: string,
        request: Scout.ListAgentSessionsObservabilityAgentsAgentIdSessionsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { start_date: startDate, end_date: endDate } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `observability/agents/${encodeURIComponent(agent_id)}/sessions`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /observability/agents/{agent_id}/sessions.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} agent_id
     * @param {Scout.ListAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.listAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGet("agent_id", {
     *         start_date: "start_date",
     *         end_date: "end_date",
     *         limit: 1,
     *         cursor: "cursor",
     *         tool_filter: "tool_filter"
     *     })
     */
    public listAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGet(
        agent_id: string,
        request: Scout.ListAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__listAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGet(
                agent_id,
                request,
                requestOptions,
            ),
        );
    }

    private async __listAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGet(
        agent_id: string,
        request: Scout.ListAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { start_date: startDate, end_date: endDate, limit, cursor, tool_filter: toolFilter } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (cursor != null) {
            _queryParams["cursor"] = cursor;
        }

        if (toolFilter != null) {
            _queryParams["tool_filter"] = toolFilter;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `observability/agents/${encodeURIComponent(agent_id)}/sessions/summary`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /observability/agents/{agent_id}/sessions/summary.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get full session details including all traces and spans for a specific session.
     *
     * This endpoint is used when a user expands a session in the UI.
     *
     * @param {string} agent_id
     * @param {string} session_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getSessionDetailsObservabilityAgentsAgentIdSessionsSessionIdDetailsGet("agent_id", "session_id")
     */
    public getSessionDetailsObservabilityAgentsAgentIdSessionsSessionIdDetailsGet(
        agent_id: string,
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getSessionDetailsObservabilityAgentsAgentIdSessionsSessionIdDetailsGet(
                agent_id,
                session_id,
                requestOptions,
            ),
        );
    }

    private async __getSessionDetailsObservabilityAgentsAgentIdSessionsSessionIdDetailsGet(
        agent_id: string,
        session_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `observability/agents/${encodeURIComponent(agent_id)}/sessions/${encodeURIComponent(session_id)}/details`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /observability/agents/{agent_id}/sessions/{session_id}/details.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get session analytics data for a specific agent from spans table (hypertable).
     *
     * @param {string} agent_id
     * @param {Scout.GetAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGet("agent_id", {
     *         start_date: "2024-01-15T09:30:00Z",
     *         end_date: "2024-01-15T09:30:00Z"
     *     })
     */
    public getAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGet(
        agent_id: string,
        request: Scout.GetAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGet(agent_id, request, requestOptions),
        );
    }

    private async __getAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGet(
        agent_id: string,
        request: Scout.GetAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { start_date: startDate, end_date: endDate } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `observability/agents/${encodeURIComponent(agent_id)}/analytics`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /observability/agents/{agent_id}/analytics.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get tool usage statistics for a specific agent.
     *
     * This endpoint aggregates tool invocations from spans data to show
     * which tools are most frequently used by an agent.
     *
     * @param {string} agent_id
     * @param {Scout.GetAgentToolUsageObservabilityAgentsAgentIdToolUsageGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getAgentToolUsageObservabilityAgentsAgentIdToolUsageGet("agent_id", {
     *         start_date: "start_date",
     *         end_date: "end_date"
     *     })
     */
    public getAgentToolUsageObservabilityAgentsAgentIdToolUsageGet(
        agent_id: string,
        request: Scout.GetAgentToolUsageObservabilityAgentsAgentIdToolUsageGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getAgentToolUsageObservabilityAgentsAgentIdToolUsageGet(agent_id, request, requestOptions),
        );
    }

    private async __getAgentToolUsageObservabilityAgentsAgentIdToolUsageGet(
        agent_id: string,
        request: Scout.GetAgentToolUsageObservabilityAgentsAgentIdToolUsageGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { start_date: startDate, end_date: endDate } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `observability/agents/${encodeURIComponent(agent_id)}/tool-usage`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /observability/agents/{agent_id}/tool-usage.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get distinct tools used by an agent.
     *
     * This endpoint returns a clean list of all tools the agent has used
     * in the specified date range, with usage counts.
     *
     * @param {string} agent_id
     * @param {Scout.GetAgentDistinctToolsObservabilityAgentsAgentIdToolsGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getAgentDistinctToolsObservabilityAgentsAgentIdToolsGet("agent_id", {
     *         start_date: "start_date",
     *         end_date: "end_date"
     *     })
     */
    public getAgentDistinctToolsObservabilityAgentsAgentIdToolsGet(
        agent_id: string,
        request: Scout.GetAgentDistinctToolsObservabilityAgentsAgentIdToolsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getAgentDistinctToolsObservabilityAgentsAgentIdToolsGet(agent_id, request, requestOptions),
        );
    }

    private async __getAgentDistinctToolsObservabilityAgentsAgentIdToolsGet(
        agent_id: string,
        request: Scout.GetAgentDistinctToolsObservabilityAgentsAgentIdToolsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { start_date: startDate, end_date: endDate } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `observability/agents/${encodeURIComponent(agent_id)}/tools`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /observability/agents/{agent_id}/tools.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get pulse feed with enhanced filtering.
     *
     * Returns both new pulse events and legacy agent interactions.
     *
     * @param {Scout.GetPulseFeedPulseFeedGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getPulseFeedPulseFeedGet({
     *         user_id: "user_id",
     *         agent_ids: "agent_ids",
     *         action_types: "action_types",
     *         start_date: "start_date",
     *         end_date: "end_date",
     *         limit: 1,
     *         include_children: true,
     *         min_significance: 1.1
     *     })
     */
    public getPulseFeedPulseFeedGet(
        request: Scout.GetPulseFeedPulseFeedGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.PulseFeedResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getPulseFeedPulseFeedGet(request, requestOptions));
    }

    private async __getPulseFeedPulseFeedGet(
        request: Scout.GetPulseFeedPulseFeedGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.PulseFeedResponse>> {
        const {
            user_id: userId,
            agent_ids: agentIds,
            action_types: actionTypes,
            start_date: startDate,
            end_date: endDate,
            limit,
            include_children: includeChildren,
            min_significance: minSignificance,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (userId != null) {
            _queryParams["user_id"] = userId;
        }

        if (agentIds != null) {
            _queryParams["agent_ids"] = agentIds;
        }

        if (actionTypes != null) {
            _queryParams["action_types"] = actionTypes;
        }

        if (startDate != null) {
            _queryParams["start_date"] = startDate;
        }

        if (endDate != null) {
            _queryParams["end_date"] = endDate;
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (includeChildren != null) {
            _queryParams["include_children"] = includeChildren.toString();
        }

        if (minSignificance != null) {
            _queryParams["min_significance"] = minSignificance.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/feed",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.PulseFeedResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/feed.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create pulse from JSON data (existing endpoint)
     *
     * @param {Scout.CreatePulseRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.createPulseJsonPulsePost({
     *         description: "description",
     *         agents: [{
     *                 "key": "value"
     *             }]
     *     })
     */
    public createPulseJsonPulsePost(
        request: Scout.CreatePulseRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.CreatePulseResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createPulseJsonPulsePost(request, requestOptions));
    }

    private async __createPulseJsonPulsePost(
        request: Scout.CreatePulseRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.CreatePulseResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.CreatePulseResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get activities - either for a specific entity or with general filters
     *
     * @param {Scout.GetEntityActivitiesPulseActivitiesGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getEntityActivitiesPulseActivitiesGet({
     *         entity_id: "entity_id",
     *         entity_type: "entity_type",
     *         involving_agent: "involving_agent",
     *         on_object: "on_object",
     *         of_type: "of_type",
     *         with_outcome: "with_outcome",
     *         since_days: 1,
     *         limit: 1
     *     })
     */
    public getEntityActivitiesPulseActivitiesGet(
        request: Scout.GetEntityActivitiesPulseActivitiesGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getEntityActivitiesPulseActivitiesGet(request, requestOptions),
        );
    }

    private async __getEntityActivitiesPulseActivitiesGet(
        request: Scout.GetEntityActivitiesPulseActivitiesGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const {
            entity_id: entityId,
            entity_type: entityType,
            involving_agent: involvingAgent,
            on_object: onObject,
            of_type: ofType,
            with_outcome: withOutcome,
            since_days: sinceDays,
            limit,
        } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (entityId != null) {
            _queryParams["entity_id"] = entityId;
        }

        if (entityType != null) {
            _queryParams["entity_type"] = entityType;
        }

        if (involvingAgent != null) {
            _queryParams["involving_agent"] = involvingAgent;
        }

        if (onObject != null) {
            _queryParams["on_object"] = onObject;
        }

        if (ofType != null) {
            _queryParams["of_type"] = ofType;
        }

        if (withOutcome != null) {
            _queryParams["with_outcome"] = withOutcome;
        }

        if (sinceDays != null) {
            _queryParams["since_days"] = sinceDays.toString();
        }

        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/activities",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/activities.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create a new entity.
     *
     * Example:
     *     POST /pulse/store/create
     *     {
     *         "type": "todo",
     *         "data": {
     *             "title": "Buy milk",
     *             "completed": false
     *         }
     *     }
     *
     * @param {Scout.CreateEntityRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeCreatePulseStoreCreatePost({
     *         type: "type",
     *         data: {
     *             "key": "value"
     *         }
     *     })
     */
    public storeCreatePulseStoreCreatePost(
        request: Scout.CreateEntityRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(this.__storeCreatePulseStoreCreatePost(request, requestOptions));
    }

    private async __storeCreatePulseStoreCreatePost(
        request: Scout.CreateEntityRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/create",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/store/create.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update an entity (partial updates).
     *
     * Example:
     *     POST /pulse/store/update
     *     {
     *         "id": "todo_abc123",
     *         "updates": {
     *             "completed": true,
     *             "completed_at": "2024-01-01T12:00:00Z"
     *         }
     *     }
     *
     * @param {Scout.UpdateEntityRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeUpdatePulseStoreUpdatePost({
     *         id: "id",
     *         updates: {
     *             "key": "value"
     *         }
     *     })
     */
    public storeUpdatePulseStoreUpdatePost(
        request: Scout.UpdateEntityRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(this.__storeUpdatePulseStoreUpdatePost(request, requestOptions));
    }

    private async __storeUpdatePulseStoreUpdatePost(
        request: Scout.UpdateEntityRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/update",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/store/update.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all unique tags across entities.
     *
     * Example:
     *     GET /pulse/store/tags?type=file&prefix=folder:
     *
     * @param {Scout.StoreGetTagsPulseStoreTagsGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeGetTagsPulseStoreTagsGet({
     *         type: "type",
     *         prefix: "prefix"
     *     })
     */
    public storeGetTagsPulseStoreTagsGet(
        request: Scout.StoreGetTagsPulseStoreTagsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.TagsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__storeGetTagsPulseStoreTagsGet(request, requestOptions));
    }

    private async __storeGetTagsPulseStoreTagsGet(
        request: Scout.StoreGetTagsPulseStoreTagsGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.TagsResponse>> {
        const { type: type_, prefix } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (type_ != null) {
            _queryParams["type"] = type_;
        }

        if (prefix != null) {
            _queryParams["prefix"] = prefix;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/tags",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.TagsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/store/tags.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Add or remove tags from an entity.
     *
     * Example:
     *     POST /pulse/store/tags/update
     *     {
     *         "id": "file-uuid",
     *         "add_tags": ["folder:marketing", "folder:campaigns"],
     *         "remove_tags": ["folder:archive"]
     *     }
     *
     * @param {Scout.UpdateTagsRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeUpdateTagsPulseStoreTagsUpdatePost({
     *         id: "id"
     *     })
     */
    public storeUpdateTagsPulseStoreTagsUpdatePost(
        request: Scout.UpdateTagsRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__storeUpdateTagsPulseStoreTagsUpdatePost(request, requestOptions),
        );
    }

    private async __storeUpdateTagsPulseStoreTagsUpdatePost(
        request: Scout.UpdateTagsRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/tags/update",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/store/tags/update.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a single entity.
     *
     * GET /pulse/store/{entity_id}
     *
     * @param {string} entity_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeGetPulseStoreEntityIdGet("entity_id")
     */
    public storeGetPulseStoreEntityIdGet(
        entity_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(this.__storeGetPulseStoreEntityIdGet(entity_id, requestOptions));
    }

    private async __storeGetPulseStoreEntityIdGet(
        entity_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/store/${encodeURIComponent(entity_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/store/{entity_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete an entity.
     *
     * DELETE /pulse/store/{entity_id}?soft=true
     *
     * @param {string} entity_id
     * @param {Scout.StoreDeletePulseStoreEntityIdDeleteRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeDeletePulseStoreEntityIdDelete("entity_id", {
     *         soft: true
     *     })
     */
    public storeDeletePulseStoreEntityIdDelete(
        entity_id: string,
        request: Scout.StoreDeletePulseStoreEntityIdDeleteRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__storeDeletePulseStoreEntityIdDelete(entity_id, request, requestOptions),
        );
    }

    private async __storeDeletePulseStoreEntityIdDelete(
        entity_id: string,
        request: Scout.StoreDeletePulseStoreEntityIdDeleteRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        const { soft } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (soft != null) {
            _queryParams["soft"] = soft.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/store/${encodeURIComponent(entity_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling DELETE /pulse/store/{entity_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Query entities with filters.
     *
     * Example:
     *     POST /pulse/store/query
     *     {
     *         "type": "file",
     *         "tags": ["folder:marketing"],
     *         "filter": {
     *             "completed": false
     *         },
     *         "limit": 50
     *     }
     *
     * @param {Scout.QueryRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeQueryPulseStoreQueryPost()
     */
    public storeQueryPulseStoreQueryPost(
        request: Scout.QueryRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(this.__storeQueryPulseStoreQueryPost(request, requestOptions));
    }

    private async __storeQueryPulseStoreQueryPost(
        request: Scout.QueryRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/query",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/store/query.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Powerful fluent query API with relationships and advanced filtering.
     *
     * Example:
     *     POST /pulse/store/query/fluent
     *     {
     *         "select": "deal",
     *         "where": [
     *             {"field": "stage", "operator": "in", "value": ["negotiation", "proposal"]},
     *             {"field": "value", "operator": ">=", "value": 50000}
     *         ],
     *         "with": ["account", "contact"],
     *         "orderBy": [{"field": "value", "direction": "desc"}],
     *         "limit": 50
     *     }
     *
     * Returns:
     *     {
     *         "ok": true,
     *         "data": [entity, ...],
     *         "total": 123,
     *         "includes": {
     *             "account": {entity_id: account_entity},
     *             "contact": {entity_id: contact_entity}
     *         }
     *     }
     *
     * @param {Scout.FluentQueryRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeQueryFluentPulseStoreQueryFluentPost({
     *         select: "select"
     *     })
     */
    public storeQueryFluentPulseStoreQueryFluentPost(
        request: Scout.FluentQueryRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Record<string, unknown>> {
        return core.HttpResponsePromise.fromPromise(
            this.__storeQueryFluentPulseStoreQueryFluentPost(request, requestOptions),
        );
    }

    private async __storeQueryFluentPulseStoreQueryFluentPost(
        request: Scout.FluentQueryRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Record<string, unknown>>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/query/fluent",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Record<string, unknown>, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/store/query/fluent.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Create multiple entities.
     *
     * Example:
     *     POST /pulse/store/batch/create
     *     {
     *         "entities": [
     *             {"type": "todo", "data": {"title": "Task 1"}},
     *             {"type": "todo", "data": {"title": "Task 2"}}
     *         ]
     *     }
     *
     * @param {Scout.BatchCreateRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.storeBatchCreatePulseStoreBatchCreatePost({
     *         entities: [{
     *                 type: "type",
     *                 data: {
     *                     "key": "value"
     *                 }
     *             }]
     *     })
     */
    public storeBatchCreatePulseStoreBatchCreatePost(
        request: Scout.BatchCreateRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.StoreResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__storeBatchCreatePulseStoreBatchCreatePost(request, requestOptions),
        );
    }

    private async __storeBatchCreatePulseStoreBatchCreatePost(
        request: Scout.BatchCreateRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.StoreResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/store/batch/create",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.StoreResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/store/batch/create.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * List all entities extracted from activities.
     *
     * Returns entities with their mention counts and metadata.
     * Used by the frontend ChannelEntitiesPanel.
     *
     * @param {Scout.ListEntitiesPulseEntitiesGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.listEntitiesPulseEntitiesGet({
     *         limit: 1,
     *         entity_type: "entity_type",
     *         current_state: true
     *     })
     */
    public listEntitiesPulseEntitiesGet(
        request: Scout.ListEntitiesPulseEntitiesGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__listEntitiesPulseEntitiesGet(request, requestOptions));
    }

    private async __listEntitiesPulseEntitiesGet(
        request: Scout.ListEntitiesPulseEntitiesGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { limit, entity_type: entityType, current_state: currentState } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (limit != null) {
            _queryParams["limit"] = limit.toString();
        }

        if (entityType != null) {
            _queryParams["entity_type"] = entityType;
        }

        if (currentState != null) {
            _queryParams["current_state"] = currentState.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/entities",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/entities.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Query entities (agents or objects) across activities
     *
     * Examples:
     *
     * # Find all sales agents
     * {
     *     "entity_type": "agent",
     *     "tags": ["sales"],
     *     "include_stats": true
     * }
     *
     * # Find documents involved in approved deals
     * {
     *     "entity_type": "object",
     *     "kinds": ["document", "contract"],
     *     "outcomes": ["approved"],
     *     "include_stats": true
     * }
     *
     * # Find active users in last 7 days
     * {
     *     "entity_type": "agent",
     *     "kinds": ["user"],
     *     "time": {"last": "7d"},
     *     "min_activities": 5,
     *     "include_stats": true
     * }
     *
     * # Find cross-functional agents (sales + engineering)
     * {
     *     "entity_type": "agent",
     *     "tags": ["sales", "engineering"],
     *     "group_by": "kind"
     * }
     *
     * @param {Scout.EntityQueryRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.queryEntitiesPulseEntitiesQueryPost()
     */
    public queryEntitiesPulseEntitiesQueryPost(
        request: Scout.EntityQueryRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__queryEntitiesPulseEntitiesQueryPost(request, requestOptions),
        );
    }

    private async __queryEntitiesPulseEntitiesQueryPost(
        request: Scout.EntityQueryRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/entities/query",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/entities/query.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get the collaboration network around an entity
     *
     * Returns entities connected to the target entity through shared activities
     *
     * @param {string} entity_id
     * @param {Scout.GetEntityNetworkPulseEntitiesEntityIdNetworkGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getEntityNetworkPulseEntitiesEntityIdNetworkGet("entity_id", {
     *         depth: 1,
     *         min_interactions: 1
     *     })
     */
    public getEntityNetworkPulseEntitiesEntityIdNetworkGet(
        entity_id: string,
        request: Scout.GetEntityNetworkPulseEntitiesEntityIdNetworkGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getEntityNetworkPulseEntitiesEntityIdNetworkGet(entity_id, request, requestOptions),
        );
    }

    private async __getEntityNetworkPulseEntitiesEntityIdNetworkGet(
        entity_id: string,
        request: Scout.GetEntityNetworkPulseEntitiesEntityIdNetworkGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { depth, min_interactions: minInteractions } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (depth != null) {
            _queryParams["depth"] = depth.toString();
        }

        if (minInteractions != null) {
            _queryParams["min_interactions"] = minInteractions.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/entities/${encodeURIComponent(entity_id)}/network`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /pulse/entities/{entity_id}/network.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get the collaboration network around an entity using PostgreSQL.
     *
     * Returns entities connected to the target entity through shared activities.
     * This is optimized for PostgreSQL and uses efficient SQL queries instead of
     * multiple API calls.
     *
     * @param {string} entity_id
     * @param {Scout.GetEntityNetworkPgPulseEntitiesEntityIdNetworkPgGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getEntityNetworkPgPulseEntitiesEntityIdNetworkPgGet("entity_id", {
     *         depth: 1,
     *         min_interactions: 1
     *     })
     */
    public getEntityNetworkPgPulseEntitiesEntityIdNetworkPgGet(
        entity_id: string,
        request: Scout.GetEntityNetworkPgPulseEntitiesEntityIdNetworkPgGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getEntityNetworkPgPulseEntitiesEntityIdNetworkPgGet(entity_id, request, requestOptions),
        );
    }

    private async __getEntityNetworkPgPulseEntitiesEntityIdNetworkPgGet(
        entity_id: string,
        request: Scout.GetEntityNetworkPgPulseEntitiesEntityIdNetworkPgGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { depth, min_interactions: minInteractions } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (depth != null) {
            _queryParams["depth"] = depth.toString();
        }

        if (minInteractions != null) {
            _queryParams["min_interactions"] = minInteractions.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/entities/${encodeURIComponent(entity_id)}/network/pg`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /pulse/entities/{entity_id}/network/pg.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get detailed information about a specific entity
     *
     * When current_state=true, uses quantum collapse to return only the latest state.
     * Otherwise includes all activities they've been involved in and collaboration patterns.
     *
     * @param {string} entity_type
     * @param {string} entity_id
     * @param {Scout.GetEntityDetailsPulseEntitiesEntityTypeEntityIdGetRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getEntityDetailsPulseEntitiesEntityTypeEntityIdGet("entity_type", "entity_id", {
     *         include_activities: true,
     *         time_range: "time_range",
     *         current_state: true
     *     })
     */
    public getEntityDetailsPulseEntitiesEntityTypeEntityIdGet(
        entity_type: string,
        entity_id: string,
        request: Scout.GetEntityDetailsPulseEntitiesEntityTypeEntityIdGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getEntityDetailsPulseEntitiesEntityTypeEntityIdGet(entity_type, entity_id, request, requestOptions),
        );
    }

    private async __getEntityDetailsPulseEntitiesEntityTypeEntityIdGet(
        entity_type: string,
        entity_id: string,
        request: Scout.GetEntityDetailsPulseEntitiesEntityTypeEntityIdGetRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { include_activities: includeActivities, time_range: timeRange, current_state: currentState } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (includeActivities != null) {
            _queryParams["include_activities"] = includeActivities.toString();
        }

        if (timeRange != null) {
            _queryParams["time_range"] = timeRange;
        }

        if (currentState != null) {
            _queryParams["current_state"] = currentState.toString();
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/entities/${encodeURIComponent(entity_type)}/${encodeURIComponent(entity_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /pulse/entities/{entity_type}/{entity_id}.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get all schemas for dynamic form generation.
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getSchemasPulseSchemasGet()
     */
    public getSchemasPulseSchemasGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SchemasResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getSchemasPulseSchemasGet(requestOptions));
    }

    private async __getSchemasPulseSchemasGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SchemasResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/schemas",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.SchemasResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/schemas.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Hybrid search for activities using PostgreSQL full-text and vector search.
     *
     * Thin handler - delegates to PulseSearch domain API.
     *
     * @param {Scout.SearchRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.searchActivitiesPulseSearchPost()
     */
    public searchActivitiesPulseSearchPost(
        request: Scout.SearchRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__searchActivitiesPulseSearchPost(request, requestOptions));
    }

    private async __searchActivitiesPulseSearchPost(
        request: Scout.SearchRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/search",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/search.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Search for entities with document content using hybrid search.
     *
     * Thin handler - delegates to PulseSearch domain API.
     *
     * @param {Scout.EntitySearchRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.searchEntitiesPulseSearchEntitiesPost({
     *         query: "query"
     *     })
     */
    public searchEntitiesPulseSearchEntitiesPost(
        request: Scout.EntitySearchRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__searchEntitiesPulseSearchEntitiesPost(request, requestOptions),
        );
    }

    private async __searchEntitiesPulseSearchEntitiesPost(
        request: Scout.EntitySearchRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/search/entities",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/search/entities.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update search indexes for existing activities.
     *
     * Thin handler - delegates to PulseSearch domain API.
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.updateSearchIndexesPulseSearchUpdateIndexesPost()
     */
    public updateSearchIndexesPulseSearchUpdateIndexesPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateSearchIndexesPulseSearchUpdateIndexesPost(requestOptions),
        );
    }

    private async __updateSearchIndexesPulseSearchUpdateIndexesPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/search/update-indexes",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/search/update-indexes.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get distinct values for a specific field to help with query building.
     *
     * Thin handler - delegates to PulseSearch domain API.
     *
     * @param {string} field
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getDistinctValuesPulseSearchDistinctFieldGet("field")
     */
    public getDistinctValuesPulseSearchDistinctFieldGet(
        field: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getDistinctValuesPulseSearchDistinctFieldGet(field, requestOptions),
        );
    }

    private async __getDistinctValuesPulseSearchDistinctFieldGet(
        field: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/search/distinct/${encodeURIComponent(field)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/search/distinct/{field}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Execute a declarative query using the powerful PulseQuery builder
     *
     * This endpoint provides a more structured and powerful alternative to text-based search,
     * allowing complex filtering, aggregation, and business logic queries.
     *
     * Examples:
     *
     * # Find all activities by specific agents in last 7 days
     * {
     *     "agent_types": ["user"],
     *     "last_days": 7,
     *     "sort_by": "time"
     * }
     *
     * # Customer journey analysis
     * {
     *     "customer_id": "customer_123",
     *     "last_days": 30,
     *     "sort_by": "time",
     *     "sort_direction": "asc"
     * }
     *
     * # Revenue impact events with duration filters
     * {
     *     "revenue_impact": true,
     *     "min_duration_minutes": 5,
     *     "tags": ["sales", "deal"],
     *     "tag_mode": "all"
     * }
     *
     * # Aggregated metrics by team
     * {
     *     "last_days": 14,
     *     "aggregate": true,
     *     "group_by": ["agent_type"],
     *     "team_name": "engineering"
     * }
     *
     * @param {Scout.QueryBuilderRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.queryBuilderPulseQueryPost()
     */
    public queryBuilderPulseQueryPost(
        request: Scout.QueryBuilderRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__queryBuilderPulseQueryPost(request, requestOptions));
    }

    private async __queryBuilderPulseQueryPost(
        request: Scout.QueryBuilderRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/query",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/query.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get the schema for the query builder, showing all available filters and options
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.queryBuilderSchemaPulseQuerySchemaGet()
     */
    public queryBuilderSchemaPulseQuerySchemaGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__queryBuilderSchemaPulseQuerySchemaGet(requestOptions));
    }

    private async __queryBuilderSchemaPulseQuerySchemaGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/query/schema",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/query/schema.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Upload files to Pulse with activity tracking and optional RAG processing.
     * Returns a streaming response with progress updates.
     *
     * Thin handler - delegates to PulseFiles domain API.
     *
     * @param {Scout.BodyUploadPulseFilesStreamPulseFilesStreamPost} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.uploadPulseFilesStreamPulseFilesStreamPost({
     *         files: [fs.createReadStream("/path/to/your/file")]
     *     })
     */
    public uploadPulseFilesStreamPulseFilesStreamPost(
        request: Scout.BodyUploadPulseFilesStreamPulseFilesStreamPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__uploadPulseFilesStreamPulseFilesStreamPost(request, requestOptions),
        );
    }

    private async __uploadPulseFilesStreamPulseFilesStreamPost(
        request: Scout.BodyUploadPulseFilesStreamPulseFilesStreamPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _request = await core.newFormData();
        for (const _file of request.files) {
            await _request.appendFile("files", _file);
        }

        const _maybeEncodedRequest = await _request.getRequest();
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/files/stream",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /pulse/files/stream.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get list of files for an organization.
     *
     * Thin handler - delegates to PulseFiles domain API.
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getPulseFilesPulseFilesGet()
     */
    public getPulseFilesPulseFilesGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getPulseFilesPulseFilesGet(requestOptions));
    }

    private async __getPulseFilesPulseFilesGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/files",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/files.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get a signed URL for downloading a file.
     *
     * Thin handler - delegates to PulseFiles domain API.
     *
     * @param {string} file_name
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.downloadPulseFilePulseFilesFileNameGet("file_name")
     */
    public downloadPulseFilePulseFilesFileNameGet(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__downloadPulseFilePulseFilesFileNameGet(file_name, requestOptions),
        );
    }

    private async __downloadPulseFilePulseFilesFileNameGet(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/files/${encodeURIComponent(file_name)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /pulse/files/{file_name}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Delete a file and its associated chunks.
     *
     * Thin handler - delegates to PulseFiles domain API.
     *
     * @param {string} file_name
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.deletePulseFilePulseFilesFileNameDelete("file_name")
     */
    public deletePulseFilePulseFilesFileNameDelete(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__deletePulseFilePulseFilesFileNameDelete(file_name, requestOptions),
        );
    }

    private async __deletePulseFilePulseFilesFileNameDelete(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/files/${encodeURIComponent(file_name)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling DELETE /pulse/files/{file_name}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get RAG document chunks for a file.
     *
     * Thin handler - delegates to PulseFiles domain API.
     *
     * @param {string} file_name
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getFileChunksPulseFilesFileNameChunksGet("file_name")
     */
    public getFileChunksPulseFilesFileNameChunksGet(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getFileChunksPulseFilesFileNameChunksGet(file_name, requestOptions),
        );
    }

    private async __getFileChunksPulseFilesFileNameChunksGet(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/files/${encodeURIComponent(file_name)}/chunks`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /pulse/files/{file_name}/chunks.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Generate AI suggestion for a security question using RAG.
     *
     * Thin handler - delegates to PulseQuestionnaire domain API.
     *
     * @param {Scout.GenerateAiSuggestionRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.generateAiSuggestionPulseSecurityQuestionnaireAiSuggestPost({
     *         question_id: "question_id",
     *         question_text: "question_text",
     *         category: "category",
     *         questionnaire_id: "questionnaire_id"
     *     })
     */
    public generateAiSuggestionPulseSecurityQuestionnaireAiSuggestPost(
        request: Scout.GenerateAiSuggestionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__generateAiSuggestionPulseSecurityQuestionnaireAiSuggestPost(request, requestOptions),
        );
    }

    private async __generateAiSuggestionPulseSecurityQuestionnaireAiSuggestPost(
        request: Scout.GenerateAiSuggestionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/security-questionnaire/ai-suggest",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling POST /pulse/security-questionnaire/ai-suggest.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Generate AI suggestions for multiple questions in batch.
     *
     * Thin handler - delegates to PulseQuestionnaire domain API.
     *
     * @param {Scout.BatchGenerateRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.generateBatchSuggestionsPulseSecurityQuestionnaireBatchSuggestPost({
     *         question_ids: ["question_ids"],
     *         questionnaire_id: "questionnaire_id"
     *     })
     */
    public generateBatchSuggestionsPulseSecurityQuestionnaireBatchSuggestPost(
        request: Scout.BatchGenerateRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__generateBatchSuggestionsPulseSecurityQuestionnaireBatchSuggestPost(request, requestOptions),
        );
    }

    private async __generateBatchSuggestionsPulseSecurityQuestionnaireBatchSuggestPost(
        request: Scout.BatchGenerateRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "pulse/security-questionnaire/batch-suggest",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling POST /pulse/security-questionnaire/batch-suggest.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update the selected files for a questionnaire.
     *
     * Thin handler - delegates to PulseQuestionnaire domain API.
     *
     * @param {string} questionnaire_id
     * @param {Scout.UpdateQuestionnaireFilesRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.updateQuestionnaireFilesPulseSecurityQuestionnaireQuestionnaireIdFilesPut("questionnaire_id", {
     *         file_ids: ["file_ids"]
     *     })
     */
    public updateQuestionnaireFilesPulseSecurityQuestionnaireQuestionnaireIdFilesPut(
        questionnaire_id: string,
        request: Scout.UpdateQuestionnaireFilesRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateQuestionnaireFilesPulseSecurityQuestionnaireQuestionnaireIdFilesPut(
                questionnaire_id,
                request,
                requestOptions,
            ),
        );
    }

    private async __updateQuestionnaireFilesPulseSecurityQuestionnaireQuestionnaireIdFilesPut(
        questionnaire_id: string,
        request: Scout.UpdateQuestionnaireFilesRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/security-questionnaire/${encodeURIComponent(questionnaire_id)}/files`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling PUT /pulse/security-questionnaire/{questionnaire_id}/files.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get questionnaire with all its questions loaded.
     *
     * Thin handler - delegates to PulseQuestionnaire domain API.
     *
     * @param {string} questionnaire_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getQuestionnaireWithQuestionsPulseSecurityQuestionnaireQuestionnaireIdGet("questionnaire_id")
     */
    public getQuestionnaireWithQuestionsPulseSecurityQuestionnaireQuestionnaireIdGet(
        questionnaire_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getQuestionnaireWithQuestionsPulseSecurityQuestionnaireQuestionnaireIdGet(
                questionnaire_id,
                requestOptions,
            ),
        );
    }

    private async __getQuestionnaireWithQuestionsPulseSecurityQuestionnaireQuestionnaireIdGet(
        questionnaire_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `pulse/security-questionnaire/${encodeURIComponent(questionnaire_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling GET /pulse/security-questionnaire/{questionnaire_id}.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Manually seed default agent personas for a new organization.
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.seedAgentsOnboardingSeedAgentsPost()
     */
    public seedAgentsOnboardingSeedAgentsPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__seedAgentsOnboardingSeedAgentsPost(requestOptions));
    }

    private async __seedAgentsOnboardingSeedAgentsPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "onboarding/seed-agents",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /onboarding/seed-agents.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get the current authenticated user's information.
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.findMeMeGet()
     */
    public findMeMeGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesOnboardingHandleGetMeResponse> {
        return core.HttpResponsePromise.fromPromise(this.__findMeMeGet(requestOptions));
    }

    private async __findMeMeGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesOnboardingHandleGetMeResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "me",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesOnboardingHandleGetMeResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /me.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Update the current authenticated user's information.
     *
     * @param {Scout.MeUpdate} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.updateMeMePut()
     */
    public updateMeMePut(
        request: Scout.MeUpdate = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.SrcAppHttpRoutesOnboardingHandleUpdateMeResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateMeMePut(request, requestOptions));
    }

    private async __updateMeMePut(
        request: Scout.MeUpdate = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.SrcAppHttpRoutesOnboardingHandleUpdateMeResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "me",
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return {
                data: _response.body as Scout.SrcAppHttpRoutesOnboardingHandleUpdateMeResponse,
                rawResponse: _response.rawResponse,
            };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling PUT /me.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.findAllScoutHooksHooksGet()
     */
    public findAllScoutHooksHooksGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ScoutHooksResponse> {
        return core.HttpResponsePromise.fromPromise(this.__findAllScoutHooksHooksGet(requestOptions));
    }

    private async __findAllScoutHooksHooksGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ScoutHooksResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "hooks",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ScoutHooksResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /hooks.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.ScoutHookUpdate} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.createScoutHookHooksPost({})
     */
    public createScoutHookHooksPost(
        request: Scout.ScoutHookUpdate,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ScoutHookResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createScoutHookHooksPost(request, requestOptions));
    }

    private async __createScoutHookHooksPost(
        request: Scout.ScoutHookUpdate,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ScoutHookResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "hooks",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ScoutHookResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /hooks.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} hook_id
     * @param {Scout.ScoutHookUpdate} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.updateScoutHookHooksHookIdPut("hook_id", {})
     */
    public updateScoutHookHooksHookIdPut(
        hook_id: string,
        request: Scout.ScoutHookUpdate,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ScoutHookResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__updateScoutHookHooksHookIdPut(hook_id, request, requestOptions),
        );
    }

    private async __updateScoutHookHooksHookIdPut(
        hook_id: string,
        request: Scout.ScoutHookUpdate,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ScoutHookResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `hooks/${encodeURIComponent(hook_id)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ScoutHookResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling PUT /hooks/{hook_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} hook_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.removeScoutHookHooksHookIdDelete("hook_id")
     */
    public removeScoutHookHooksHookIdDelete(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__removeScoutHookHooksHookIdDelete(hook_id, requestOptions));
    }

    private async __removeScoutHookHooksHookIdDelete(
        hook_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `hooks/${encodeURIComponent(hook_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling DELETE /hooks/{hook_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Rotate API keys for the current organization.
     *
     * Delegates to ProfileManager for the actual business logic.
     *
     * @param {Scout.RotateApiKeysRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.rotateApiKeysOrganizationRotateKeysPost()
     */
    public rotateApiKeysOrganizationRotateKeysPost(
        request: Scout.RotateApiKeysRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__rotateApiKeysOrganizationRotateKeysPost(request, requestOptions),
        );
    }

    private async __rotateApiKeysOrganizationRotateKeysPost(
        request: Scout.RotateApiKeysRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "organization/rotate-keys",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /organization/rotate-keys.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.listTagsTagsGet()
     */
    public listTagsTagsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ListTagsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listTagsTagsGet(requestOptions));
    }

    private async __listTagsTagsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ListTagsResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "tags",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ListTagsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /tags.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SrcAppHttpRoutesTagsCreateTagPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.createTagTagsPost({
     *         name: "name"
     *     })
     */
    public createTagTagsPost(
        request: Scout.SrcAppHttpRoutesTagsCreateTagPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.CreateTagResponse> {
        return core.HttpResponsePromise.fromPromise(this.__createTagTagsPost(request, requestOptions));
    }

    private async __createTagTagsPost(
        request: Scout.SrcAppHttpRoutesTagsCreateTagPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.CreateTagResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "tags",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.CreateTagResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /tags.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} tag_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getTagTagsTagIdGet("tag_id")
     */
    public getTagTagsTagIdGet(
        tag_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.Tag> {
        return core.HttpResponsePromise.fromPromise(this.__getTagTagsTagIdGet(tag_id, requestOptions));
    }

    private async __getTagTagsTagIdGet(
        tag_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.Tag>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `tags/${encodeURIComponent(tag_id)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.Tag, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /tags/{tag_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} tag_id
     * @param {Scout.SrcAppHttpRoutesTagsUpdateTagPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.updateTagTagsTagIdPut("tag_id")
     */
    public updateTagTagsTagIdPut(
        tag_id: string,
        request: Scout.SrcAppHttpRoutesTagsUpdateTagPayload = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.UpdateTagResponse> {
        return core.HttpResponsePromise.fromPromise(this.__updateTagTagsTagIdPut(tag_id, request, requestOptions));
    }

    private async __updateTagTagsTagIdPut(
        tag_id: string,
        request: Scout.SrcAppHttpRoutesTagsUpdateTagPayload = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.UpdateTagResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `tags/${encodeURIComponent(tag_id)}`,
            ),
            method: "PUT",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.UpdateTagResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling PUT /tags/{tag_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get available tools for the organization with full input schemas.
     *
     * This endpoint delegates to the Tool domain API which provides:
     * - Tool authorization checking
     * - Schema retrieval from all sources
     * - Comprehensive tool information
     *
     * Args:
     *     request: The FastAPI request
     *
     * Returns:
     *     ListToolsResponse with detailed tool information
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.listToolsToolsGet()
     */
    public listToolsToolsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ListToolsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__listToolsToolsGet(requestOptions));
    }

    private async __listToolsToolsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ListToolsResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "tools",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ListToolsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /tools.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get detailed information about a specific tool.
     *
     * This endpoint returns comprehensive information about a single tool including:
     * - Tool metadata (name, description, icon)
     * - Input schema
     * - Labels and categorization
     *
     * Args:
     *     request: The FastAPI request
     *     tool_name: The name of the tool to retrieve
     *
     * Returns:
     *     ToolDetails with comprehensive tool information
     *
     * Raises:
     *     HTTPException: 404 if tool not found, 403 if not available
     *
     * @param {string} tool_name
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getToolToolsToolNameGet("tool_name")
     */
    public getToolToolsToolNameGet(
        tool_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ToolDetails> {
        return core.HttpResponsePromise.fromPromise(this.__getToolToolsToolNameGet(tool_name, requestOptions));
    }

    private async __getToolToolsToolNameGet(
        tool_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ToolDetails>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `tools/${encodeURIComponent(tool_name)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ToolDetails, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /tools/{tool_name}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Execute a specific tool.
     *
     * This endpoint delegates to the Tool domain API which handles:
     * - Tool authorization
     * - Tool discovery from all sources
     * - Context injection
     * - Tool execution
     *
     * Args:
     *     request: The FastAPI request
     *     tool_name: The name of the tool to execute (from path parameter)
     *     body: The tool execution request body
     *
     * Returns:
     *     ExecuteToolResponse with execution result or error
     *
     * @param {string} tool_name
     * @param {Scout.ExecuteToolRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.executeToolToolsToolNameExecutePost("tool_name")
     */
    public executeToolToolsToolNameExecutePost(
        tool_name: string,
        request: Scout.ExecuteToolRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ExecuteToolResponse> {
        return core.HttpResponsePromise.fromPromise(
            this.__executeToolToolsToolNameExecutePost(tool_name, request, requestOptions),
        );
    }

    private async __executeToolToolsToolNameExecutePost(
        tool_name: string,
        request: Scout.ExecuteToolRequest = {},
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ExecuteToolResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `tools/${encodeURIComponent(tool_name)}/execute`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ExecuteToolResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /tools/{tool_name}/execute.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} agent_id
     * @param {string} session_id
     * @param {Scout.SrcAppHttpRoutesWorldInteractInteractionRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.interactHandlerWorldAgentIdSessionIdInteractPost("agent_id", "session_id", {
     *         messages: [{
     *                 content: "content"
     *             }]
     *     })
     */
    public interactHandlerWorldAgentIdSessionIdInteractPost(
        agent_id: string,
        session_id: string,
        request: Scout.SrcAppHttpRoutesWorldInteractInteractionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__interactHandlerWorldAgentIdSessionIdInteractPost(agent_id, session_id, request, requestOptions),
        );
    }

    private async __interactHandlerWorldAgentIdSessionIdInteractPost(
        agent_id: string,
        session_id: string,
        request: Scout.SrcAppHttpRoutesWorldInteractInteractionRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `world/${encodeURIComponent(agent_id)}/${encodeURIComponent(session_id)}/_interact`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError(
                    "Timeout exceeded when calling POST /world/{agent_id}/{session_id}/_interact.",
                );
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} agent_id
     * @param {Scout.InteractHandlerWorldAgentIdInteractPostRequest} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.interactHandlerWorldAgentIdInteractPost("agent_id", {
     *         session_id: "session_id",
     *         body: {
     *             messages: [{
     *                     content: "content"
     *                 }]
     *         }
     *     })
     */
    public interactHandlerWorldAgentIdInteractPost(
        agent_id: string,
        request: Scout.InteractHandlerWorldAgentIdInteractPostRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__interactHandlerWorldAgentIdInteractPost(agent_id, request, requestOptions),
        );
    }

    private async __interactHandlerWorldAgentIdInteractPost(
        agent_id: string,
        request: Scout.InteractHandlerWorldAgentIdInteractPostRequest,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const { session_id: sessionId, body: _body } = request;
        const _queryParams: Record<string, string | string[] | object | object[] | null> = {};
        if (sessionId != null) {
            _queryParams["session_id"] = sessionId;
        }

        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `world/${encodeURIComponent(agent_id)}/_interact`,
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: { ..._queryParams, ...requestOptions?.queryParams },
            requestType: "json",
            body: _body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /world/{agent_id}/_interact.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.listAgentsAgentsGet()
     */
    public listAgentsAgentsGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__listAgentsAgentsGet(requestOptions));
    }

    private async __listAgentsAgentsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "agents",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /agents.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.BodyUpsertAgentAgentsPost} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.upsertAgentAgentsPost({
     *         agent_image: fs.createReadStream("/path/to/your/file"),
     *         agent: "agent",
     *         revision: "revision"
     *     })
     */
    public upsertAgentAgentsPost(
        request: Scout.BodyUpsertAgentAgentsPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__upsertAgentAgentsPost(request, requestOptions));
    }

    private async __upsertAgentAgentsPost(
        request: Scout.BodyUpsertAgentAgentsPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _request = await core.newFormData();
        _request.append("agent", request.agent);
        if (request.agent_id != null) {
            _request.append("agent_id", request.agent_id);
        }

        if (request.activate != null) {
            _request.append("activate", request.activate.toString());
        }

        _request.append("revision", request.revision);
        await _request.appendFile("agent_image", request.agent_image);
        const _maybeEncodedRequest = await _request.getRequest();
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "agents",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /agents.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Retrieve an agent and its active revision by agent_id.
     * Verifies that the agent belongs to the actor's organization.
     *
     * @param {string} agent_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getActiveAgentAgentsAgentIdActiveGet("agent_id")
     */
    public getActiveAgentAgentsAgentIdActiveGet(
        agent_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getActiveAgentAgentsAgentIdActiveGet(agent_id, requestOptions),
        );
    }

    private async __getActiveAgentAgentsAgentIdActiveGet(
        agent_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `agents/${encodeURIComponent(agent_id)}/active`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /agents/{agent_id}/active.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Get available tools for the organization.
     *
     * Args:
     *     request: The FastAPI request
     *
     * Returns:
     *     Span with the list of available tools attached to its attributes
     *
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getToolsAgentsToolsGet()
     */
    public getToolsAgentsToolsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<Scout.ToolsResponse> {
        return core.HttpResponsePromise.fromPromise(this.__getToolsAgentsToolsGet(requestOptions));
    }

    private async __getToolsAgentsToolsGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<Scout.ToolsResponse>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "agents/tools",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body as Scout.ToolsResponse, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /agents/tools.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} agent_id
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.deleteAgentAgentsAgentIdDelete("agent_id")
     */
    public deleteAgentAgentsAgentIdDelete(
        agent_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__deleteAgentAgentsAgentIdDelete(agent_id, requestOptions));
    }

    private async __deleteAgentAgentsAgentIdDelete(
        agent_id: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `agents/${encodeURIComponent(agent_id)}`,
            ),
            method: "DELETE",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling DELETE /agents/{agent_id}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.expireBlobsExpireBlobsPost()
     */
    public expireBlobsExpireBlobsPost(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__expireBlobsExpireBlobsPost(requestOptions));
    }

    private async __expireBlobsExpireBlobsPost(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "_expire_blobs",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /_expire_blobs.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @example
     *     await client.getDriveDriveGet()
     */
    public getDriveDriveGet(requestOptions?: ScoutClient.RequestOptions): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__getDriveDriveGet(requestOptions));
    }

    private async __getDriveDriveGet(
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "drive",
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            throw new errors.ScoutError({
                statusCode: _response.error.statusCode,
                body: _response.error.body,
                rawResponse: _response.rawResponse,
            });
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /drive.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {string} file_name
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.getDriveFileDriveFilesFileNameGet("file_name")
     */
    public getDriveFileDriveFilesFileNameGet(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(
            this.__getDriveFileDriveFilesFileNameGet(file_name, requestOptions),
        );
    }

    private async __getDriveFileDriveFilesFileNameGet(
        file_name: string,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                `drive/files/${encodeURIComponent(file_name)}`,
            ),
            method: "GET",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling GET /drive/files/{file_name}.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.BodyUploadFilesToDriveDriveFilesPost} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     import { createReadStream } from "fs";
     *     await client.uploadFilesToDriveDriveFilesPost({
     *         files: [fs.createReadStream("/path/to/your/file")]
     *     })
     */
    public uploadFilesToDriveDriveFilesPost(
        request: Scout.BodyUploadFilesToDriveDriveFilesPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__uploadFilesToDriveDriveFilesPost(request, requestOptions));
    }

    private async __uploadFilesToDriveDriveFilesPost(
        request: Scout.BodyUploadFilesToDriveDriveFilesPost,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        const _request = await core.newFormData();
        for (const _file of request.files) {
            await _request.appendFile("files", _file);
        }

        const _maybeEncodedRequest = await _request.getRequest();
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({
                Authorization: await this._getAuthorizationHeader(),
                ..._maybeEncodedRequest.headers,
            }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "drive/files",
            ),
            method: "POST",
            headers: _headers,
            queryParameters: requestOptions?.queryParams,
            requestType: "file",
            duplex: _maybeEncodedRequest.duplex,
            body: _maybeEncodedRequest.body,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /drive/files.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * Since we do not have domain apis for collections we have to import
     * the route functions and pass the request through.
     *
     * We could get the org key and move this logic to the drive domain api
     * but we would then need to get the org secret key to make http requests
     * since importing into the drive domain api would cause circular dependencies.
     * Which then forces us to use network requests via scout sdk or httpx.
     *
     * This is the lesser evil I.M.O.
     *
     * @param {Scout.SrcAppHttpRoutesDriveCreateDriveCrawlPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.createDriveCrawlDriveCrawlsPost({
     *         source_sync_settings: {
     *             source_archetype_id: "com.google.drive"
     *         },
     *         url: "url"
     *     })
     */
    public createDriveCrawlDriveCrawlsPost(
        request: Scout.SrcAppHttpRoutesDriveCreateDriveCrawlPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__createDriveCrawlDriveCrawlsPost(request, requestOptions));
    }

    private async __createDriveCrawlDriveCrawlsPost(
        request: Scout.SrcAppHttpRoutesDriveCreateDriveCrawlPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "drive/crawls",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /drive/crawls.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SrcAppHttpRoutesDriveGrantAccessPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.grantAccessDriveGrantPost({
     *         agent_ids: ["agent_ids"],
     *         resources: [{
     *                 resource_id: "resource_id",
     *                 resource_type: "tables"
     *             }]
     *     })
     */
    public grantAccessDriveGrantPost(
        request: Scout.SrcAppHttpRoutesDriveGrantAccessPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__grantAccessDriveGrantPost(request, requestOptions));
    }

    private async __grantAccessDriveGrantPost(
        request: Scout.SrcAppHttpRoutesDriveGrantAccessPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "drive/grant",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /drive/grant.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    /**
     * @param {Scout.SrcAppHttpRoutesDriveRevokeAccessPayload} request
     * @param {ScoutClient.RequestOptions} requestOptions - Request-specific configuration.
     *
     * @throws {@link Scout.UnprocessableEntityError}
     *
     * @example
     *     await client.revokeAccessDriveRevokePost({
     *         agent_ids: ["agent_ids"],
     *         resource_ids: ["resource_ids"]
     *     })
     */
    public revokeAccessDriveRevokePost(
        request: Scout.SrcAppHttpRoutesDriveRevokeAccessPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): core.HttpResponsePromise<unknown> {
        return core.HttpResponsePromise.fromPromise(this.__revokeAccessDriveRevokePost(request, requestOptions));
    }

    private async __revokeAccessDriveRevokePost(
        request: Scout.SrcAppHttpRoutesDriveRevokeAccessPayload,
        requestOptions?: ScoutClient.RequestOptions,
    ): Promise<core.WithRawResponse<unknown>> {
        let _headers: core.Fetcher.Args["headers"] = mergeHeaders(
            this._options?.headers,
            mergeOnlyDefinedHeaders({ Authorization: await this._getAuthorizationHeader() }),
            requestOptions?.headers,
        );
        const _response = await (this._options.fetcher ?? core.fetcher)({
            url: core.url.join(
                (await core.Supplier.get(this._options.baseUrl)) ??
                    (await core.Supplier.get(this._options.environment)) ??
                    environments.ScoutEnvironment.Prod,
                "drive/revoke",
            ),
            method: "POST",
            headers: _headers,
            contentType: "application/json",
            queryParameters: requestOptions?.queryParams,
            requestType: "json",
            body: request,
            timeoutMs: requestOptions?.timeoutInSeconds != null ? requestOptions.timeoutInSeconds * 1000 : 60000,
            maxRetries: requestOptions?.maxRetries,
            abortSignal: requestOptions?.abortSignal,
        });
        if (_response.ok) {
            return { data: _response.body, rawResponse: _response.rawResponse };
        }

        if (_response.error.reason === "status-code") {
            switch (_response.error.statusCode) {
                case 422:
                    throw new Scout.UnprocessableEntityError(
                        _response.error.body as Scout.HttpValidationError,
                        _response.rawResponse,
                    );
                default:
                    throw new errors.ScoutError({
                        statusCode: _response.error.statusCode,
                        body: _response.error.body,
                        rawResponse: _response.rawResponse,
                    });
            }
        }

        switch (_response.error.reason) {
            case "non-json":
                throw new errors.ScoutError({
                    statusCode: _response.error.statusCode,
                    body: _response.error.rawBody,
                    rawResponse: _response.rawResponse,
                });
            case "timeout":
                throw new errors.ScoutTimeoutError("Timeout exceeded when calling POST /drive/revoke.");
            case "unknown":
                throw new errors.ScoutError({
                    message: _response.error.errorMessage,
                    rawResponse: _response.rawResponse,
                });
        }
    }

    protected async _getAuthorizationHeader(): Promise<string | undefined> {
        const bearer = (await core.Supplier.get(this._options.apiKey)) ?? process?.env["SCOUT_API_KEY"];
        if (bearer != null) {
            return `Bearer ${bearer}`;
        }

        return undefined;
    }
}
