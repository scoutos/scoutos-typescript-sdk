// This file was auto-generated by Fern from our API Definition.

import { mockServerPool } from "../mock-server/MockServerPool";
import { ScoutClient } from "../../src/Client";
import * as Scout from "../../src/api/index";

describe("Documents", () => {
    test("list (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    document_id: "document_id",
                    document_data_id: "document_data_id",
                    created_at: "2024-01-15T09:30:00Z",
                    last_updated_at: "2024-01-15T09:30:00Z",
                    created_by: { type: "user", details: undefined },
                    last_updated_by: { type: "user", details: undefined },
                    revision_id: "revision_id",
                    job_id: "job_id",
                    sync_id: "sync_id",
                    studio_row: true,
                    cells: { key: "value" },
                },
            ],
            next_cursor: "next_cursor",
            has_more: true,
            total_count: 1,
            documents_uploading: true,
        };
        server
            .mockEndpoint()
            .get("/v2/collections/collection_id/tables/table_id/documents")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.list("collection_id", "table_id", {
            limit: 1,
            cursor: "cursor",
            query: "query",
            offset: 1,
            sort_by: "sort_by",
        });
        expect(response).toEqual({
            data: [
                {
                    document_id: "document_id",
                    document_data_id: "document_data_id",
                    created_at: "2024-01-15T09:30:00Z",
                    last_updated_at: "2024-01-15T09:30:00Z",
                    created_by: {
                        type: "user",
                        details: undefined,
                    },
                    last_updated_by: {
                        type: "user",
                        details: undefined,
                    },
                    revision_id: "revision_id",
                    job_id: "job_id",
                    sync_id: "sync_id",
                    studio_row: true,
                    cells: {
                        key: "value",
                    },
                },
            ],
            next_cursor: "next_cursor",
            has_more: true,
            total_count: 1,
            documents_uploading: true,
        });
    });

    test("list (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/v2/collections/collection_id/tables/table_id/documents")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.list("collection_id", "table_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("create (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { key: true };
        const rawResponseBody = {
            data: [
                {
                    document_id: "document_id",
                    document_data_id: "document_data_id",
                    created_at: "2024-01-15T09:30:00Z",
                    last_updated_at: "2024-01-15T09:30:00Z",
                    created_by: { type: "user", details: undefined },
                    last_updated_by: { type: "user", details: undefined },
                    revision_id: "revision_id",
                    job_id: "job_id",
                    sync_id: "sync_id",
                    studio_row: true,
                    cells: { key: "value" },
                },
            ],
            status: "status",
        };
        server
            .mockEndpoint()
            .post("/v2/collections/collection_id/tables/table_id/documents")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.create("collection_id", "table_id", {
            job_id: "job_id",
            sync_id: "sync_id",
            await_completion: true,
            mode: "mode",
            body: {
                key: true,
            },
        });
        expect(response).toEqual({
            data: [
                {
                    document_id: "document_id",
                    document_data_id: "document_data_id",
                    created_at: "2024-01-15T09:30:00Z",
                    last_updated_at: "2024-01-15T09:30:00Z",
                    created_by: {
                        type: "user",
                        details: undefined,
                    },
                    last_updated_by: {
                        type: "user",
                        details: undefined,
                    },
                    revision_id: "revision_id",
                    job_id: "job_id",
                    sync_id: "sync_id",
                    studio_row: true,
                    cells: {
                        key: "value",
                    },
                },
            ],
            status: "status",
        });
    });

    test("create (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { string: true };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/v2/collections/collection_id/tables/table_id/documents")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.create("collection_id", "table_id", {
                body: {
                    string: true,
                },
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update_batch (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { key: true };
        const rawResponseBody = {
            data: [
                {
                    document_id: "document_id",
                    document_data_id: "document_data_id",
                    created_at: "2024-01-15T09:30:00Z",
                    last_updated_at: "2024-01-15T09:30:00Z",
                    created_by: { type: "user", details: undefined },
                    last_updated_by: { type: "user", details: undefined },
                    revision_id: "revision_id",
                    job_id: "job_id",
                    sync_id: "sync_id",
                    studio_row: true,
                    cells: { key: "value" },
                },
            ],
            status: "status",
        };
        server
            .mockEndpoint()
            .post("/v2/collections/collection_id/tables/table_id/documents/update")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.updateBatch("collection_id", "table_id", {
            job_id: "job_id",
            sync_id: "sync_id",
            await_completion: true,
            mode: "mode",
            body: {
                key: true,
            },
        });
        expect(response).toEqual({
            data: [
                {
                    document_id: "document_id",
                    document_data_id: "document_data_id",
                    created_at: "2024-01-15T09:30:00Z",
                    last_updated_at: "2024-01-15T09:30:00Z",
                    created_by: {
                        type: "user",
                        details: undefined,
                    },
                    last_updated_by: {
                        type: "user",
                        details: undefined,
                    },
                    revision_id: "revision_id",
                    job_id: "job_id",
                    sync_id: "sync_id",
                    studio_row: true,
                    cells: {
                        key: "value",
                    },
                },
            ],
            status: "status",
        });
    });

    test("update_batch (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { string: true };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/v2/collections/collection_id/tables/table_id/documents/update")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.updateBatch("collection_id", "table_id", {
                body: {
                    string: true,
                },
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                document_id: "document_id",
                data: { key: "value" },
                document_data_id: "document_data_id",
                created_at: "2024-01-15T09:30:00Z",
                last_updated_at: "2024-01-15T09:30:00Z",
                created_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: { key: "value" },
                    },
                },
                last_updated_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: { key: "value" },
                    },
                },
                revision_id: "revision_id",
                job_id: "job_id",
                sync_id: "sync_id",
                studio_row: true,
                cells: { key: "value" },
            },
        };
        server
            .mockEndpoint()
            .get("/v2/collections/collection_id/tables/table_id/documents/document_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.get("collection_id", "table_id", "document_id");
        expect(response).toEqual({
            data: {
                document_id: "document_id",
                data: {
                    key: "value",
                },
                document_data_id: "document_data_id",
                created_at: "2024-01-15T09:30:00Z",
                last_updated_at: "2024-01-15T09:30:00Z",
                created_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: {
                            key: "value",
                        },
                    },
                },
                last_updated_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: {
                            key: "value",
                        },
                    },
                },
                revision_id: "revision_id",
                job_id: "job_id",
                sync_id: "sync_id",
                studio_row: true,
                cells: {
                    key: "value",
                },
            },
        });
    });

    test("get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/v2/collections/collection_id/tables/table_id/documents/document_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.get("collection_id", "table_id", "document_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            data: {
                document_id: "document_id",
                data: { key: "value" },
                document_data_id: "document_data_id",
                created_at: "2024-01-15T09:30:00Z",
                last_updated_at: "2024-01-15T09:30:00Z",
                created_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: { key: "value" },
                    },
                },
                last_updated_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: { key: "value" },
                    },
                },
                revision_id: "revision_id",
                job_id: "job_id",
                sync_id: "sync_id",
                studio_row: true,
                cells: { key: "value" },
            },
        };
        server
            .mockEndpoint()
            .put("/v2/collections/collection_id/tables/table_id/documents/document_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.update("collection_id", "table_id", "document_id", {});
        expect(response).toEqual({
            data: {
                document_id: "document_id",
                data: {
                    key: "value",
                },
                document_data_id: "document_data_id",
                created_at: "2024-01-15T09:30:00Z",
                last_updated_at: "2024-01-15T09:30:00Z",
                created_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: {
                            key: "value",
                        },
                    },
                },
                last_updated_by: {
                    type: "user",
                    details: {
                        user_id: "user_id",
                        org_id: "org_id",
                        scout_organization_id: "scout_organization_id",
                        email: {
                            key: "value",
                        },
                    },
                },
                revision_id: "revision_id",
                job_id: "job_id",
                sync_id: "sync_id",
                studio_row: true,
                cells: {
                    key: "value",
                },
            },
        });
    });

    test("update (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { string: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .put("/v2/collections/collection_id/tables/table_id/documents/document_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.update("collection_id", "table_id", "document_id", {
                string: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: "detail", status_code: 1 };
        server
            .mockEndpoint()
            .delete("/v2/collections/collection_id/tables/table_id/documents/document_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.delete("collection_id", "table_id", "document_id");
        expect(response).toEqual({
            detail: "detail",
            status_code: 1,
        });
    });

    test("delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/v2/collections/collection_id/tables/table_id/documents/document_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.delete("collection_id", "table_id", "document_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("delete_batch (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = ["string"];
        const rawResponseBody = { detail: "detail", status_code: 1 };
        server
            .mockEndpoint()
            .post("/v2/collections/collection_id/tables/table_id/documents/delete")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.documents.deleteBatch("collection_id", "table_id", ["string"]);
        expect(response).toEqual({
            detail: "detail",
            status_code: 1,
        });
    });

    test("delete_batch (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = ["string", "string"];
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/v2/collections/collection_id/tables/table_id/documents/delete")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.documents.deleteBatch("collection_id", "table_id", ["string", "string"]);
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });
});
