// This file was auto-generated by Fern from our API Definition.

import { mockServerPool } from "../mock-server/MockServerPool";
import { ScoutClient } from "../../src/Client";
import * as Scout from "../../src/api/index";

describe("ScoutClient", () => {
    test("info_handler_info_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            message: "message",
            service: { name: "Big Boi", sha: "sha", container_start_time: "container_start_time" },
        };
        server.mockEndpoint().get("/info").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.infoHandlerInfoGet();
        expect(response).toEqual({
            message: "message",
            service: {
                name: "Big Boi",
                sha: "sha",
                container_start_time: "container_start_time",
            },
        });
    });

    test("get_info_v2_triggers_info_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v2/triggers/info").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getInfoV2TriggersInfoGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_info_v2_index_info_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v2/index/info").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getInfoV2IndexInfoGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_info_v2_workflows_info_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/v2/workflows/info").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getInfoV2WorkflowsInfoGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_info_v2_collections_info_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/v2/collections/info")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getInfoV2CollectionsInfoGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_integrations_integrations_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                name: "name",
                id: "hubspot",
                auth_client: "auth_client",
                description: "description",
                auth_types: [{ type: "api_key" }],
                icon_url: "icon_url",
                metadata: { key: "value" },
                tags: ["tags"],
                enabled: true,
                permissions: [{ key: "value" }],
                auth_configs: { key: "value" },
                connected: true,
                connections: [
                    {
                        id: "id",
                        auth_client: "auth_client",
                        integration_type: "hubspot",
                        auth_type: "api_key",
                        api_key_secret_ref: undefined,
                        access_token_secret_ref: undefined,
                        refresh_token_secret_ref: undefined,
                        client_id_secret_ref: undefined,
                        client_secret_secret_ref: undefined,
                        connected: true,
                        metadata: undefined,
                        scopes: undefined,
                        created_at: "2024-01-15T09:30:00Z",
                        updated_at: "2024-01-15T09:30:00Z",
                        expires_in: undefined,
                    },
                ],
                existing_auth_client_scope: ["existing_auth_client_scope"],
                supports_multiple_connections: true,
            },
        ];
        server.mockEndpoint().get("/integrations").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getIntegrationsIntegrationsGet();
        expect(response).toEqual([
            {
                name: "name",
                id: "hubspot",
                auth_client: "auth_client",
                description: "description",
                auth_types: [
                    {
                        type: "api_key",
                    },
                ],
                icon_url: "icon_url",
                metadata: {
                    key: "value",
                },
                tags: ["tags"],
                enabled: true,
                permissions: [
                    {
                        key: "value",
                    },
                ],
                auth_configs: {
                    key: "value",
                },
                connected: true,
                connections: [
                    {
                        id: "id",
                        auth_client: "auth_client",
                        integration_type: "hubspot",
                        auth_type: "api_key",
                        api_key_secret_ref: undefined,
                        access_token_secret_ref: undefined,
                        refresh_token_secret_ref: undefined,
                        client_id_secret_ref: undefined,
                        client_secret_secret_ref: undefined,
                        connected: true,
                        metadata: undefined,
                        scopes: undefined,
                        created_at: "2024-01-15T09:30:00Z",
                        updated_at: "2024-01-15T09:30:00Z",
                        expires_in: undefined,
                    },
                ],
                existing_auth_client_scope: ["existing_auth_client_scope"],
                supports_multiple_connections: true,
            },
        ]);
    });

    test("get_integration_integrations__integration_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            name: "name",
            id: "hubspot",
            auth_client: "auth_client",
            description: "description",
            auth_types: [{ type: "api_key" }],
            icon_url: "icon_url",
            metadata: { key: "value" },
            tags: ["tags"],
            enabled: true,
            permissions: [{ key: "value" }],
            auth_configs: { key: "value" },
            connected: true,
            connections: [
                {
                    id: "id",
                    auth_client: "auth_client",
                    integration_type: "hubspot",
                    auth_type: "api_key",
                    api_key_secret_ref: "api_key_secret_ref",
                    access_token_secret_ref: "access_token_secret_ref",
                    refresh_token_secret_ref: "refresh_token_secret_ref",
                    client_id_secret_ref: "client_id_secret_ref",
                    client_secret_secret_ref: "client_secret_secret_ref",
                    connected: true,
                    metadata: { key: "value" },
                    scopes: ["scopes"],
                    created_at: "2024-01-15T09:30:00Z",
                    updated_at: "2024-01-15T09:30:00Z",
                    expires_in: 1,
                    has_permission: true,
                },
            ],
            existing_auth_client_scope: ["existing_auth_client_scope"],
            supports_multiple_connections: true,
        };
        server
            .mockEndpoint()
            .get("/integrations/integration_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getIntegrationIntegrationsIntegrationIdGet("integration_id");
        expect(response).toEqual({
            name: "name",
            id: "hubspot",
            auth_client: "auth_client",
            description: "description",
            auth_types: [
                {
                    type: "api_key",
                },
            ],
            icon_url: "icon_url",
            metadata: {
                key: "value",
            },
            tags: ["tags"],
            enabled: true,
            permissions: [
                {
                    key: "value",
                },
            ],
            auth_configs: {
                key: "value",
            },
            connected: true,
            connections: [
                {
                    id: "id",
                    auth_client: "auth_client",
                    integration_type: "hubspot",
                    auth_type: "api_key",
                    api_key_secret_ref: "api_key_secret_ref",
                    access_token_secret_ref: "access_token_secret_ref",
                    refresh_token_secret_ref: "refresh_token_secret_ref",
                    client_id_secret_ref: "client_id_secret_ref",
                    client_secret_secret_ref: "client_secret_secret_ref",
                    connected: true,
                    metadata: {
                        key: "value",
                    },
                    scopes: ["scopes"],
                    created_at: "2024-01-15T09:30:00Z",
                    updated_at: "2024-01-15T09:30:00Z",
                    expires_in: 1,
                    has_permission: true,
                },
            ],
            existing_auth_client_scope: ["existing_auth_client_scope"],
            supports_multiple_connections: true,
        });
    });

    test("get_integration_integrations__integration_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/integrations/integration_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getIntegrationIntegrationsIntegrationIdGet("integration_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_integration_connections_integrations__integration_id__connections_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = [
            {
                id: "id",
                auth_client: "auth_client",
                integration_type: "hubspot",
                auth_type: "api_key",
                api_key_secret_ref: "api_key_secret_ref",
                access_token_secret_ref: "access_token_secret_ref",
                refresh_token_secret_ref: "refresh_token_secret_ref",
                client_id_secret_ref: "client_id_secret_ref",
                client_secret_secret_ref: "client_secret_secret_ref",
                connected: true,
                metadata: { key: "value" },
                scopes: ["scopes"],
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                expires_in: 1,
                has_permission: true,
            },
        ];
        server
            .mockEndpoint()
            .get("/integrations/integration_id/connections")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response =
            await client.getIntegrationConnectionsIntegrationsIntegrationIdConnectionsGet("integration_id");
        expect(response).toEqual([
            {
                id: "id",
                auth_client: "auth_client",
                integration_type: "hubspot",
                auth_type: "api_key",
                api_key_secret_ref: "api_key_secret_ref",
                access_token_secret_ref: "access_token_secret_ref",
                refresh_token_secret_ref: "refresh_token_secret_ref",
                client_id_secret_ref: "client_id_secret_ref",
                client_secret_secret_ref: "client_secret_secret_ref",
                connected: true,
                metadata: {
                    key: "value",
                },
                scopes: ["scopes"],
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                expires_in: 1,
                has_permission: true,
            },
        ]);
    });

    test("get_integration_connections_integrations__integration_id__connections_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/integrations/integration_id/connections")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getIntegrationConnectionsIntegrationsIntegrationIdConnectionsGet("integration_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("connect_integration_integrations__integration_id__connect_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { auth_type: "api_key" };
        const rawResponseBody = {
            success: true,
            connected_integration: {
                id: "id",
                auth_client: "auth_client",
                integration_type: "hubspot",
                auth_type: "api_key",
                api_key_secret_ref: "api_key_secret_ref",
                access_token_secret_ref: "access_token_secret_ref",
                refresh_token_secret_ref: "refresh_token_secret_ref",
                client_id_secret_ref: "client_id_secret_ref",
                client_secret_secret_ref: "client_secret_secret_ref",
                connected: true,
                metadata: { key: "value" },
                scopes: ["scopes"],
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                expires_in: 1,
                has_permission: true,
            },
            error: "error",
            auth_url: "auth_url",
        };
        server
            .mockEndpoint()
            .post("/integrations/integration_id/connect")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.connectIntegrationIntegrationsIntegrationIdConnectPost("integration_id", {
            auth_type: "api_key",
        });
        expect(response).toEqual({
            success: true,
            connected_integration: {
                id: "id",
                auth_client: "auth_client",
                integration_type: "hubspot",
                auth_type: "api_key",
                api_key_secret_ref: "api_key_secret_ref",
                access_token_secret_ref: "access_token_secret_ref",
                refresh_token_secret_ref: "refresh_token_secret_ref",
                client_id_secret_ref: "client_id_secret_ref",
                client_secret_secret_ref: "client_secret_secret_ref",
                connected: true,
                metadata: {
                    key: "value",
                },
                scopes: ["scopes"],
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                expires_in: 1,
                has_permission: true,
            },
            error: "error",
            auth_url: "auth_url",
        });
    });

    test("connect_integration_integrations__integration_id__connect_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            auth_type: "api_key",
            api_key: undefined,
            code: undefined,
            state: undefined,
            scope: undefined,
            client_id: undefined,
            client_secret: undefined,
            environment: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/integrations/integration_id/connect")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.connectIntegrationIntegrationsIntegrationIdConnectPost("integration_id", {
                auth_type: "api_key",
                api_key: undefined,
                code: undefined,
                state: undefined,
                scope: undefined,
                client_id: undefined,
                client_secret: undefined,
                environment: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_send_message_integrations_slack_send_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { channel_id: "channel_id", text: "text" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/integrations/slack/send")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleSendMessageIntegrationsSlackSendPost({
            channel_id: "channel_id",
            text: "text",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_send_message_integrations_slack_send_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            channel_id: "channel_id",
            text: "text",
            thread_id: undefined,
            blocks: undefined,
            username: undefined,
            icon_url: undefined,
            integration_id: undefined,
            unfurl_links: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/integrations/slack/send")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleSendMessageIntegrationsSlackSendPost({
                channel_id: "channel_id",
                text: "text",
                thread_id: undefined,
                blocks: undefined,
                username: undefined,
                icon_url: undefined,
                integration_id: undefined,
                unfurl_links: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_add_reaction_integrations_slack_react_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { channel_id: "channel_id", emoji_name: "emoji_name" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/integrations/slack/react")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleAddReactionIntegrationsSlackReactPost({
            channel_id: "channel_id",
            emoji_name: "emoji_name",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_add_reaction_integrations_slack_react_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            channel_id: "channel_id",
            emoji_name: "emoji_name",
            thread_id: undefined,
            integration_id: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/integrations/slack/react")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleAddReactionIntegrationsSlackReactPost({
                channel_id: "channel_id",
                emoji_name: "emoji_name",
                thread_id: undefined,
                integration_id: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_get_thread_integrations_slack_thread_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/integrations/slack/thread")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleGetThreadIntegrationsSlackThreadGet({
            channel_id: "channel_id",
            thread_id: "thread_id",
            integration_id: "integration_id",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_thread_integrations_slack_thread_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/integrations/slack/thread")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleGetThreadIntegrationsSlackThreadGet({
                channel_id: "channel_id",
                thread_id: "thread_id",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_get_team_info_integrations_slack_team_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/integrations/slack/team")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleGetTeamInfoIntegrationsSlackTeamGet({
            team_id: "team_id",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_team_info_integrations_slack_team_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/integrations/slack/team")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleGetTeamInfoIntegrationsSlackTeamGet({
                team_id: "team_id",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_list_channels_integrations_slack_channels_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/integrations/slack/channels")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleListChannelsIntegrationsSlackChannelsGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_list_channels_integrations_slack_channels_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/integrations/slack/channels")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleListChannelsIntegrationsSlackChannelsGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_migrate_integrations_integrations_migrate_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/integrations/migrate")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleMigrateIntegrationsIntegrationsMigratePost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_notion_oauth_integrations_notion_oauth_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { access_token: "access_token", metadata: { key: "value" } };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/integrations/notion/oauth")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleNotionOauthIntegrationsNotionOauthPost({
            access_token: "access_token",
            metadata: {
                key: "value",
            },
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_notion_oauth_integrations_notion_oauth_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            access_token: "access_token",
            integrated_service_id: undefined,
            metadata: { metadata: { key: "value" } },
            code: undefined,
            redirect_uri: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/integrations/notion/oauth")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleNotionOauthIntegrationsNotionOauthPost({
                access_token: "access_token",
                integrated_service_id: undefined,
                metadata: {
                    metadata: {
                        key: "value",
                    },
                },
                code: undefined,
                redirect_uri: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("exchange_mcp_auth_mcp_authorization_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            code: "code",
            state: "state",
            url: "url",
            name: "name",
            integration_id: "integration_id",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/mcp/authorization")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.exchangeMcpAuthMcpAuthorizationPost({
            code: "code",
            state: "state",
            url: "url",
            name: "name",
            integration_id: "integration_id",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("exchange_mcp_auth_mcp_authorization_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            code: "code",
            state: "state",
            url: "url",
            name: "name",
            integration_id: "integration_id",
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/mcp/authorization")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.exchangeMcpAuthMcpAuthorizationPost({
                code: "code",
                state: "state",
                url: "url",
                name: "name",
                integration_id: "integration_id",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("connect_mcp_mcp_connect_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { url: "url", name: "name", integration_id: "integration_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/mcp/connect")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.connectMcpMcpConnectPost({
            url: "url",
            name: "name",
            integration_id: "integration_id",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("connect_mcp_mcp_connect_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { url: "url", name: "name", headers: undefined, integration_id: "integration_id" };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/mcp/connect")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.connectMcpMcpConnectPost({
                url: "url",
                name: "name",
                headers: undefined,
                integration_id: "integration_id",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("delete_mcp_connection_mcp_servers__connection_id__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/mcp/servers/connection_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.deleteMcpConnectionMcpServersConnectionIdDelete("connection_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("delete_mcp_connection_mcp_servers__connection_id__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/mcp/servers/connection_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deleteMcpConnectionMcpServersConnectionIdDelete("connection_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_mcp_servers_mcp_servers_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/mcp/servers").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getMcpServersMcpServersGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_info_inbox_info_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/inbox/info").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getInfoInboxInfoGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_sessions_inbox_sessions_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/inbox/sessions").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.handleGetSessionsInboxSessionsGet({
            search: "search",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_sessions_inbox_sessions_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/inbox/sessions").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.handleGetSessionsInboxSessionsGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_get_notifications_inbox_notifications_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/inbox/notifications")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleGetNotificationsInboxNotificationsGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_session_by_id_inbox__session_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/inbox/session_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.handleGetSessionByIdInboxSessionIdGet("session_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_session_by_id_inbox__session_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/inbox/session_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.handleGetSessionByIdInboxSessionIdGet("session_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_delete_session_inbox__session_id__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { status: "status", session_id: "session_id" };
        server
            .mockEndpoint()
            .delete("/inbox/session_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleDeleteSessionInboxSessionIdDelete("session_id");
        expect(response).toEqual({
            status: "status",
            session_id: "session_id",
        });
    });

    test("handle_delete_session_inbox__session_id__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/inbox/session_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleDeleteSessionInboxSessionIdDelete("session_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_transcribe_inbox__session_id__transcribe_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/inbox/session_id/transcribe")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleTranscribeInboxSessionIdTranscribePost("session_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_session_messages_inbox__session_id__messages_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/inbox/session_id/messages")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleGetSessionMessagesInboxSessionIdMessagesGet("session_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_get_session_messages_inbox__session_id__messages_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/inbox/session_id/messages")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleGetSessionMessagesInboxSessionIdMessagesGet("session_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_message_inbox__session_id__messages_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            messages: [{ content: "content", content_type: "text/plain" }],
            participants: [{ id: "id" }],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/inbox/session_id/messages")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleMessageInboxSessionIdMessagesPost("session_id", {
            messages: [
                {
                    content: "content",
                    content_type: "text/plain",
                },
            ],
            participants: [
                {
                    id: "id",
                },
            ],
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_message_inbox__session_id__messages_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            messages: [
                { content: "content", content_type: "text/plain" },
                { content: "content", content_type: "text/plain" },
            ],
            participants: [
                { id: "id", type: undefined },
                { id: "id", type: undefined },
            ],
            history: undefined,
            files: undefined,
            mentions: undefined,
            ephemeral_agent_revision: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/inbox/session_id/messages")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleMessageInboxSessionIdMessagesPost("session_id", {
                messages: [
                    {
                        content: "content",
                        content_type: "text/plain",
                    },
                    {
                        content: "content",
                        content_type: "text/plain",
                    },
                ],
                participants: [
                    {
                        id: "id",
                        type: undefined,
                    },
                    {
                        id: "id",
                        type: undefined,
                    },
                ],
                history: undefined,
                files: undefined,
                mentions: undefined,
                ephemeral_agent_revision: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_post_session_participant_inbox_sessions__session_id__participants_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = [{ id: "id", type: "scout_user" }];
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/inbox/sessions/session_id/participants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handlePostSessionParticipantInboxSessionsSessionIdParticipantsPost("session_id", [
            {
                id: "id",
                type: "scout_user",
            },
        ]);
        expect(response).toEqual({
            key: "value",
        });
    });

    test("handle_post_session_participant_inbox_sessions__session_id__participants_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = [
            { id: "id", type: "scout_user" },
            { id: "id", type: "scout_user" },
        ];
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/inbox/sessions/session_id/participants")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handlePostSessionParticipantInboxSessionsSessionIdParticipantsPost("session_id", [
                {
                    id: "id",
                    type: "scout_user",
                },
                {
                    id: "id",
                    type: "scout_user",
                },
            ]);
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_cancel_session_inbox__session_id__cancel_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { status: "status", session_id: "session_id", cancelled_agents: 1, total_agents: 1 };
        server
            .mockEndpoint()
            .post("/inbox/session_id/cancel")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleCancelSessionInboxSessionIdCancelPost("session_id");
        expect(response).toEqual({
            status: "status",
            session_id: "session_id",
            cancelled_agents: 1,
            total_agents: 1,
        });
    });

    test("handle_cancel_session_inbox__session_id__cancel_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/inbox/session_id/cancel")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleCancelSessionInboxSessionIdCancelPost("session_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("handle_rename_session_inbox__session_id__rename_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { title: "title" };
        const rawResponseBody = { status: "status", session_id: "session_id", title: "title" };
        server
            .mockEndpoint()
            .post("/inbox/session_id/rename")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.handleRenameSessionInboxSessionIdRenamePost("session_id", {
            title: "title",
        });
        expect(response).toEqual({
            status: "status",
            session_id: "session_id",
            title: "title",
        });
    });

    test("handle_rename_session_inbox__session_id__rename_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { title: "title" };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/inbox/session_id/rename")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.handleRenameSessionInboxSessionIdRenamePost("session_id", {
                title: "title",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("execute_hook_webhooks__hook_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/webhooks/hook_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.executeHookWebhooksHookIdGet("hook_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("execute_hook_webhooks__hook_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/webhooks/hook_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.executeHookWebhooksHookIdGet("hook_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("execute_hook_webhooks__hook_id__post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().post("/webhooks/hook_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.executeHookWebhooksHookIdPost("hook_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("execute_hook_webhooks__hook_id__post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().post("/webhooks/hook_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.executeHookWebhooksHookIdPost("hook_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("delete_hook_webhooks__hook_id__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { success: true, message: "message" };
        server
            .mockEndpoint()
            .delete("/webhooks/hook_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.deleteHookWebhooksHookIdDelete("hook_id");
        expect(response).toEqual({
            success: true,
            message: "message",
        });
    });

    test("delete_hook_webhooks__hook_id__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/webhooks/hook_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deleteHookWebhooksHookIdDelete("hook_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update_hook_webhooks__hook_id__patch (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .patch("/webhooks/hook_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateHookWebhooksHookIdPatch("hook_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("update_hook_webhooks__hook_id__patch (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            name: undefined,
            description: undefined,
            status: undefined,
            target_config: undefined,
            response_mode: undefined,
            allowed_methods: undefined,
            max_payload_size: undefined,
            secret: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .patch("/webhooks/hook_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.updateHookWebhooksHookIdPatch("hook_id", {
                name: undefined,
                description: undefined,
                status: undefined,
                target_config: undefined,
                response_mode: undefined,
                allowed_methods: undefined,
                max_payload_size: undefined,
                secret: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_hooks_webhooks_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { hooks: [{ key: "value" }], count: 1 };
        server.mockEndpoint().get("/webhooks").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.listHooksWebhooksGet({
            target_type: "target_type",
            target_id: "target_id",
        });
        expect(response).toEqual({
            hooks: [
                {
                    key: "value",
                },
            ],
            count: 1,
        });
    });

    test("list_hooks_webhooks_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/webhooks").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.listHooksWebhooksGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("create_hook_webhooks_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", target_id: "target_id", target_type: "workflow" };
        const rawResponseBody = {
            id: "id",
            organization_id: "organization_id",
            name: "name",
            description: "description",
            target_id: "target_id",
            status: "status",
            response_mode: "response_mode",
            allowed_methods: ["allowed_methods"],
            max_payload_size: 1,
            secret: "secret",
            url: "url",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            created_by: { key: "value" },
            target_type: "workflow",
            target_config: {
                field_mappings: [
                    { source_path: "source_path", target_field_id: "target_field_id", transform: undefined },
                ],
                default_field_id: "default_field_id",
                run_mode: "run_mode",
                timeout_seconds: 1,
                verify_token: "verify_token",
            },
        };
        server
            .mockEndpoint()
            .post("/webhooks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createHookWebhooksPost({
            name: "name",
            target_id: "target_id",
            target_type: "workflow",
        });
        expect(response).toEqual({
            id: "id",
            organization_id: "organization_id",
            name: "name",
            description: "description",
            target_id: "target_id",
            status: "status",
            response_mode: "response_mode",
            allowed_methods: ["allowed_methods"],
            max_payload_size: 1,
            secret: "secret",
            url: "url",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            created_by: {
                key: "value",
            },
            target_type: "workflow",
            target_config: {
                field_mappings: [
                    {
                        source_path: "source_path",
                        target_field_id: "target_field_id",
                        transform: undefined,
                    },
                ],
                default_field_id: "default_field_id",
                run_mode: "run_mode",
                timeout_seconds: 1,
                verify_token: "verify_token",
            },
        });
    });

    test("create_hook_webhooks_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            name: "name",
            description: undefined,
            target_id: "target_id",
            response_mode: undefined,
            allowed_methods: undefined,
            max_payload_size: undefined,
            enable_auth: undefined,
            target_type: "workflow",
            target_config: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/webhooks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createHookWebhooksPost({
                name: "name",
                description: undefined,
                target_id: "target_id",
                response_mode: undefined,
                allowed_methods: undefined,
                max_payload_size: undefined,
                enable_auth: undefined,
                target_type: "workflow",
                target_config: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_hook_webhooks__hook_id__details_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            id: "id",
            organization_id: "organization_id",
            name: "name",
            description: "description",
            target_id: "target_id",
            status: "status",
            response_mode: "response_mode",
            allowed_methods: ["allowed_methods"],
            max_payload_size: 1,
            secret: "secret",
            url: "url",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            created_by: { key: "value" },
            target_type: "workflow",
            target_config: {
                field_mappings: [
                    { source_path: "source_path", target_field_id: "target_field_id", transform: undefined },
                ],
                default_field_id: "default_field_id",
                run_mode: "run_mode",
                timeout_seconds: 1,
                verify_token: "verify_token",
            },
        };
        server
            .mockEndpoint()
            .get("/webhooks/hook_id/details")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getHookWebhooksHookIdDetailsGet("hook_id");
        expect(response).toEqual({
            id: "id",
            organization_id: "organization_id",
            name: "name",
            description: "description",
            target_id: "target_id",
            status: "status",
            response_mode: "response_mode",
            allowed_methods: ["allowed_methods"],
            max_payload_size: 1,
            secret: "secret",
            url: "url",
            created_at: "2024-01-15T09:30:00Z",
            updated_at: "2024-01-15T09:30:00Z",
            created_by: {
                key: "value",
            },
            target_type: "workflow",
            target_config: {
                field_mappings: [
                    {
                        source_path: "source_path",
                        target_field_id: "target_field_id",
                        transform: undefined,
                    },
                ],
                default_field_id: "default_field_id",
                run_mode: "run_mode",
                timeout_seconds: 1,
                verify_token: "verify_token",
            },
        });
    });

    test("get_hook_webhooks__hook_id__details_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/webhooks/hook_id/details")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getHookWebhooksHookIdDetailsGet("hook_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_info_money_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { message: "message", container_start_time: "container_start_time" };
        server.mockEndpoint().get("/money").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getInfoMoneyGet();
        expect(response).toEqual({
            message: "message",
            container_start_time: "container_start_time",
        });
    });

    test("get_billing_accounts_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                payment_methods: [{ id: "id", brand: "brand", last4: "last4", is_default: true }],
                has_payment_method: true,
                has_default_payment_method: true,
                needs_billing_email: true,
                active_plan: {
                    plan: "plan_1",
                    interval: { type: "monthly", start_date: "2024-01-15T09:30:00Z", surcharge: 1.1 },
                },
                future_plans: [
                    {
                        plan: "plan_1",
                        interval: { type: "monthly", start_date: "2024-01-15T09:30:00Z", surcharge: 1.1 },
                    },
                ],
                billing_cycles: {
                    previous: { start_date: "2024-01-15T09:30:00Z", end_date: "2024-01-15T09:30:00Z", current: true },
                    next: { start_date: "2024-01-15T09:30:00Z", end_date: "2024-01-15T09:30:00Z", current: true },
                },
                failed_invoices: [
                    {
                        id: "id",
                        meta: { plan_name: "plan_1" },
                        status: "1000",
                        description: "description",
                        line_items: [{ amount: 1.1, unit: "USD", name: "name", description: "description" }],
                        created_at: "2024-01-15T09:30:00Z",
                        paid_at: undefined,
                        updated_at: "2024-01-15T09:30:00Z",
                        provider_meta: undefined,
                    },
                ],
                has_failed_payment: true,
                workflow_invocations: 1,
                billing_limits: {
                    seats: 1,
                    agent_interactions: 1,
                    integrations: 1,
                    workflow_invocations: 1,
                    active_workflows: 1,
                },
                agent_interactions: 1,
            },
        };
        server.mockEndpoint().get("/accounts").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getBillingAccountsGet();
        expect(response).toEqual({
            data: {
                payment_methods: [
                    {
                        id: "id",
                        brand: "brand",
                        last4: "last4",
                        is_default: true,
                    },
                ],
                has_payment_method: true,
                has_default_payment_method: true,
                needs_billing_email: true,
                active_plan: {
                    plan: "plan_1",
                    interval: {
                        type: "monthly",
                        start_date: "2024-01-15T09:30:00Z",
                        surcharge: 1.1,
                    },
                },
                future_plans: [
                    {
                        plan: "plan_1",
                        interval: {
                            type: "monthly",
                            start_date: "2024-01-15T09:30:00Z",
                            surcharge: 1.1,
                        },
                    },
                ],
                billing_cycles: {
                    previous: {
                        start_date: "2024-01-15T09:30:00Z",
                        end_date: "2024-01-15T09:30:00Z",
                        current: true,
                    },
                    next: {
                        start_date: "2024-01-15T09:30:00Z",
                        end_date: "2024-01-15T09:30:00Z",
                        current: true,
                    },
                },
                failed_invoices: [
                    {
                        id: "id",
                        meta: {
                            plan_name: "plan_1",
                        },
                        status: "1000",
                        description: "description",
                        line_items: [
                            {
                                amount: 1.1,
                                unit: "USD",
                                name: "name",
                                description: "description",
                            },
                        ],
                        created_at: "2024-01-15T09:30:00Z",
                        paid_at: undefined,
                        updated_at: "2024-01-15T09:30:00Z",
                        provider_meta: undefined,
                    },
                ],
                has_failed_payment: true,
                workflow_invocations: 1,
                billing_limits: {
                    seats: 1,
                    agent_interactions: 1,
                    integrations: 1,
                    workflow_invocations: 1,
                    active_workflows: 1,
                },
                agent_interactions: 1,
            },
        });
    });

    test("get_usage_accounts_usage_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            total: 1.1,
            data: [{ name: "crawl", friendly_date: "friendly_date", price: 1.1, display_name: "display_name" }],
        };
        server.mockEndpoint().get("/accounts/usage").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getUsageAccountsUsageGet({
            start_date: "start_date",
            end_date: "end_date",
        });
        expect(response).toEqual({
            total: 1.1,
            data: [
                {
                    name: "crawl",
                    friendly_date: "friendly_date",
                    price: 1.1,
                    display_name: "display_name",
                },
            ],
        });
    });

    test("get_usage_accounts_usage_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/accounts/usage").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getUsageAccountsUsageGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_invoices_accounts_invoices_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                invoices: [
                    {
                        id: "id",
                        url: undefined,
                        pdf: undefined,
                        amount_due: 1,
                        friendly_plan: "friendly_plan",
                        timestamp_start: 1,
                    },
                ],
            },
        };
        server.mockEndpoint().get("/accounts/invoices").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getInvoicesAccountsInvoicesGet();
        expect(response).toEqual({
            data: {
                invoices: [
                    {
                        id: "id",
                        url: undefined,
                        pdf: undefined,
                        amount_due: 1,
                        friendly_plan: "friendly_plan",
                        timestamp_start: 1,
                    },
                ],
            },
        });
    });

    test("create_portal_session_accounts_portal_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { url: "url" } };
        server.mockEndpoint().get("/accounts/portal").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.createPortalSessionAccountsPortalGet();
        expect(response).toEqual({
            data: {
                url: "url",
            },
        });
    });

    test("get_workflow_usage_accounts_usage_workflows_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/accounts/usage/workflows")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getWorkflowUsageAccountsUsageWorkflowsGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_notifications_notifications_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: [
                {
                    type: "usage_limit_reached",
                    severity: "info",
                    title: "title",
                    message: "message",
                    actions: [{ label: "label", url: "url", type: "primary" }],
                    metadata: { key: "value" },
                },
            ],
        };
        server.mockEndpoint().get("/notifications").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getNotificationsNotificationsGet();
        expect(response).toEqual({
            data: [
                {
                    type: "usage_limit_reached",
                    severity: "info",
                    title: "title",
                    message: "message",
                    actions: [
                        {
                            label: "label",
                            url: "url",
                            type: "primary",
                        },
                    ],
                    metadata: {
                        key: "value",
                    },
                },
            ],
        });
    });

    test("change_billing_plan_accounts_plan_put (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "plan_1", interval_type: "monthly" };
        const rawResponseBody = {
            data: {
                billing: {
                    provider: { provider: "stripe", customer_id: "customer_id" },
                    subscriptions: [
                        {
                            plan: "plan_1",
                            interval: { type: "monthly", start_date: "2024-01-15T09:30:00Z", surcharge: 1.1 },
                        },
                    ],
                    renewal_date: "2024-01-15T09:30:00Z",
                    limits: {
                        seats: undefined,
                        agent_interactions: undefined,
                        integrations: undefined,
                        workflow_invocations: undefined,
                        active_workflows: undefined,
                    },
                },
            },
        };
        server
            .mockEndpoint()
            .put("/accounts/plan")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.changeBillingPlanAccountsPlanPut({
            name: "plan_1",
        });
        expect(response).toEqual({
            data: {
                billing: {
                    provider: {
                        provider: "stripe",
                        customer_id: "customer_id",
                    },
                    subscriptions: [
                        {
                            plan: "plan_1",
                            interval: {
                                type: "monthly",
                                start_date: "2024-01-15T09:30:00Z",
                                surcharge: 1.1,
                            },
                        },
                    ],
                    renewal_date: "2024-01-15T09:30:00Z",
                    limits: {
                        seats: undefined,
                        agent_interactions: undefined,
                        integrations: undefined,
                        workflow_invocations: undefined,
                        active_workflows: undefined,
                    },
                },
            },
        });
    });

    test("change_billing_plan_accounts_plan_put (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "plan_1", interval_type: "monthly" };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .put("/accounts/plan")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.changeBillingPlanAccountsPlanPut({
                name: "plan_1",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("stripe_webhook_hooks_stripe_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().post("/hooks/stripe").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.stripeWebhookHooksStripePost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("renew_plans_crons_renew_plans_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { ok: true, msg: "msg" } };
        server
            .mockEndpoint()
            .post("/crons/renew_plans")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.renewPlansCronsRenewPlansPost();
        expect(response).toEqual({
            data: {
                ok: true,
                msg: "msg",
            },
        });
    });

    test("daily_billing_tasks_crons_free_plan_usage_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { ok: true, msg: "msg" } };
        server
            .mockEndpoint()
            .post("/crons/free_plan_usage")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.dailyBillingTasksCronsFreePlanUsagePost();
        expect(response).toEqual({
            data: {
                ok: true,
                msg: "msg",
            },
        });
    });

    test("billing_hourly_crons_billing_hourly_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { data: { ok: true, msg: "msg" } };
        server
            .mockEndpoint()
            .post("/crons/billing_hourly")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.billingHourlyCronsBillingHourlyPost();
        expect(response).toEqual({
            data: {
                ok: true,
                msg: "msg",
            },
        });
    });

    test("list_spans_traces__trace_id__spans_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/traces/trace_id/spans")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.listSpansTracesTraceIdSpansGet("trace_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("list_spans_traces__trace_id__spans_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/traces/trace_id/spans")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.listSpansTracesTraceIdSpansGet("trace_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_agent_sessions_observability_agents__agent_id__sessions_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/sessions")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.listAgentSessionsObservabilityAgentsAgentIdSessionsGet("agent_id", {
            start_date: "2024-01-15T09:30:00Z",
            end_date: "2024-01-15T09:30:00Z",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("list_agent_sessions_observability_agents__agent_id__sessions_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/sessions")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.listAgentSessionsObservabilityAgentsAgentIdSessionsGet("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_agent_sessions_summary_observability_agents__agent_id__sessions_summary_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/sessions/summary")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.listAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGet("agent_id", {
            start_date: "start_date",
            end_date: "end_date",
            limit: 1,
            cursor: "cursor",
            tool_filter: "tool_filter",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("list_agent_sessions_summary_observability_agents__agent_id__sessions_summary_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/sessions/summary")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.listAgentSessionsSummaryObservabilityAgentsAgentIdSessionsSummaryGet("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_session_details_observability_agents__agent_id__sessions__session_id__details_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/sessions/session_id/details")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getSessionDetailsObservabilityAgentsAgentIdSessionsSessionIdDetailsGet(
            "agent_id",
            "session_id",
        );
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_session_details_observability_agents__agent_id__sessions__session_id__details_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/sessions/session_id/details")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getSessionDetailsObservabilityAgentsAgentIdSessionsSessionIdDetailsGet(
                "agent_id",
                "session_id",
            );
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_agent_session_analytics_observability_agents__agent_id__analytics_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/analytics")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGet("agent_id", {
            start_date: "2024-01-15T09:30:00Z",
            end_date: "2024-01-15T09:30:00Z",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_agent_session_analytics_observability_agents__agent_id__analytics_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/analytics")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getAgentSessionAnalyticsObservabilityAgentsAgentIdAnalyticsGet("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_agent_tool_usage_observability_agents__agent_id__tool_usage_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/tool-usage")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getAgentToolUsageObservabilityAgentsAgentIdToolUsageGet("agent_id", {
            start_date: "start_date",
            end_date: "end_date",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_agent_tool_usage_observability_agents__agent_id__tool_usage_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/tool-usage")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getAgentToolUsageObservabilityAgentsAgentIdToolUsageGet("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_agent_distinct_tools_observability_agents__agent_id__tools_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/tools")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getAgentDistinctToolsObservabilityAgentsAgentIdToolsGet("agent_id", {
            start_date: "start_date",
            end_date: "end_date",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_agent_distinct_tools_observability_agents__agent_id__tools_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/observability/agents/agent_id/tools")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getAgentDistinctToolsObservabilityAgentsAgentIdToolsGet("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_pulse_feed_pulse_feed_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { ok: true, data: { key: "value" } };
        server.mockEndpoint().get("/pulse/feed").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getPulseFeedPulseFeedGet({
            user_id: "user_id",
            agent_ids: "agent_ids",
            action_types: "action_types",
            start_date: "start_date",
            end_date: "end_date",
            limit: 1,
            include_children: true,
            min_significance: 1.1,
        });
        expect(response).toEqual({
            ok: true,
            data: {
                key: "value",
            },
        });
    });

    test("get_pulse_feed_pulse_feed_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/pulse/feed").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getPulseFeedPulseFeedGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("create_pulse_json_pulse_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { description: "description", agents: [{ key: "value" }] };
        const rawResponseBody = { ok: true, data: { key: "value" } };
        server
            .mockEndpoint()
            .post("/pulse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createPulseJsonPulsePost({
            description: "description",
            agents: [
                {
                    key: "value",
                },
            ],
        });
        expect(response).toEqual({
            ok: true,
            data: {
                key: "value",
            },
        });
    });

    test("create_pulse_json_pulse_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            action: undefined,
            description: "description",
            agents: [{ agents: { key: "value" } }, { agents: { key: "value" } }],
            objects: undefined,
            context: undefined,
            tags: undefined,
            visibility: undefined,
            duration_minutes: undefined,
            content: undefined,
            text: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createPulseJsonPulsePost({
                action: undefined,
                description: "description",
                agents: [
                    {
                        agents: {
                            key: "value",
                        },
                    },
                    {
                        agents: {
                            key: "value",
                        },
                    },
                ],
                objects: undefined,
                context: undefined,
                tags: undefined,
                visibility: undefined,
                duration_minutes: undefined,
                content: undefined,
                text: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_entity_activities_pulse_activities_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/pulse/activities").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getEntityActivitiesPulseActivitiesGet({
            entity_id: "entity_id",
            entity_type: "entity_type",
            involving_agent: "involving_agent",
            on_object: "on_object",
            of_type: "of_type",
            with_outcome: "with_outcome",
            since_days: 1,
            limit: 1,
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_entity_activities_pulse_activities_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/pulse/activities").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getEntityActivitiesPulseActivitiesGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_create_pulse_store_create_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { type: "type", data: { key: "value" } };
        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/pulse/store/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeCreatePulseStoreCreatePost({
            type: "type",
            data: {
                key: "value",
            },
        });
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_create_pulse_store_create_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { type: "type", data: { data: { key: "value" } }, tags: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/store/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeCreatePulseStoreCreatePost({
                type: "type",
                data: {
                    data: {
                        key: "value",
                    },
                },
                tags: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_update_pulse_store_update_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { id: "id", updates: { key: "value" } };
        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/pulse/store/update")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeUpdatePulseStoreUpdatePost({
            id: "id",
            updates: {
                key: "value",
            },
        });
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_update_pulse_store_update_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { id: "id", updates: { updates: { key: "value" } } };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/store/update")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeUpdatePulseStoreUpdatePost({
                id: "id",
                updates: {
                    updates: {
                        key: "value",
                    },
                },
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_get_tags_pulse_store_tags_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { ok: true, tags: ["tags"] };
        server.mockEndpoint().get("/pulse/store/tags").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.storeGetTagsPulseStoreTagsGet({
            type: "type",
            prefix: "prefix",
        });
        expect(response).toEqual({
            ok: true,
            tags: ["tags"],
        });
    });

    test("store_get_tags_pulse_store_tags_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/pulse/store/tags").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.storeGetTagsPulseStoreTagsGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_update_tags_pulse_store_tags_update_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { id: "id" };
        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/pulse/store/tags/update")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeUpdateTagsPulseStoreTagsUpdatePost({
            id: "id",
        });
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_update_tags_pulse_store_tags_update_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { id: "id", add_tags: undefined, remove_tags: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/store/tags/update")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeUpdateTagsPulseStoreTagsUpdatePost({
                id: "id",
                add_tags: undefined,
                remove_tags: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_get_pulse_store__entity_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .get("/pulse/store/entity_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeGetPulseStoreEntityIdGet("entity_id");
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_get_pulse_store__entity_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/store/entity_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeGetPulseStoreEntityIdGet("entity_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_delete_pulse_store__entity_id__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .delete("/pulse/store/entity_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeDeletePulseStoreEntityIdDelete("entity_id", {
            soft: true,
        });
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_delete_pulse_store__entity_id__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/pulse/store/entity_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeDeletePulseStoreEntityIdDelete("entity_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_query_pulse_store_query_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/pulse/store/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeQueryPulseStoreQueryPost();
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_query_pulse_store_query_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            type: undefined,
            filter: undefined,
            tags: undefined,
            limit: undefined,
            include_deleted: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/store/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeQueryPulseStoreQueryPost({
                type: undefined,
                filter: undefined,
                tags: undefined,
                limit: undefined,
                include_deleted: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_query_fluent_pulse_store_query_fluent_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { select: "select" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/store/query/fluent")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeQueryFluentPulseStoreQueryFluentPost({
            select: "select",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("store_query_fluent_pulse_store_query_fluent_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            select: "select",
            where: undefined,
            with: undefined,
            orderBy: undefined,
            limit: undefined,
            offset: undefined,
            cursor: undefined,
            count: undefined,
            groupBy: undefined,
            aggregations: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/store/query/fluent")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeQueryFluentPulseStoreQueryFluentPost({
                select: "select",
                where: undefined,
                with: undefined,
                orderBy: undefined,
                limit: undefined,
                offset: undefined,
                cursor: undefined,
                count: undefined,
                groupBy: undefined,
                aggregations: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("store_batch_create_pulse_store_batch_create_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { entities: [{ type: "type", data: { key: "value" } }] };
        const rawResponseBody = {
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: { key: "value" },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: { key: "value" },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        };
        server
            .mockEndpoint()
            .post("/pulse/store/batch/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.storeBatchCreatePulseStoreBatchCreatePost({
            entities: [
                {
                    type: "type",
                    data: {
                        key: "value",
                    },
                },
            ],
        });
        expect(response).toEqual({
            ok: true,
            entity: {
                id: "id",
                type: "type",
                data: {
                    key: "value",
                },
                created_at: "created_at",
                updated_at: "updated_at",
                deleted: true,
            },
            entities: [
                {
                    id: "id",
                    type: "type",
                    data: {
                        key: "value",
                    },
                    created_at: "created_at",
                    updated_at: "updated_at",
                    deleted: true,
                },
            ],
            message: "message",
        });
    });

    test("store_batch_create_pulse_store_batch_create_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            entities: [
                { type: "type", data: { data: { key: "value" } }, tags: undefined },
                { type: "type", data: { data: { key: "value" } }, tags: undefined },
            ],
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/store/batch/create")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.storeBatchCreatePulseStoreBatchCreatePost({
                entities: [
                    {
                        type: "type",
                        data: {
                            data: {
                                key: "value",
                            },
                        },
                        tags: undefined,
                    },
                    {
                        type: "type",
                        data: {
                            data: {
                                key: "value",
                            },
                        },
                        tags: undefined,
                    },
                ],
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_entities_pulse_entities_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/pulse/entities").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.listEntitiesPulseEntitiesGet({
            limit: 1,
            entity_type: "entity_type",
            current_state: true,
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("list_entities_pulse_entities_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/pulse/entities").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.listEntitiesPulseEntitiesGet();
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("query_entities_pulse_entities_query_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/entities/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.queryEntitiesPulseEntitiesQueryPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("query_entities_pulse_entities_query_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            entity_type: undefined,
            activity_filters: undefined,
            tags: undefined,
            outcomes: undefined,
            actions: undefined,
            time: undefined,
            kinds: undefined,
            roles: undefined,
            current_state: undefined,
            include_stats: undefined,
            group_by: undefined,
            limit: undefined,
            min_activities: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/entities/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.queryEntitiesPulseEntitiesQueryPost({
                entity_type: undefined,
                activity_filters: undefined,
                tags: undefined,
                outcomes: undefined,
                actions: undefined,
                time: undefined,
                kinds: undefined,
                roles: undefined,
                current_state: undefined,
                include_stats: undefined,
                group_by: undefined,
                limit: undefined,
                min_activities: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_entity_network_pulse_entities__entity_id__network_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/entities/entity_id/network")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getEntityNetworkPulseEntitiesEntityIdNetworkGet("entity_id", {
            depth: 1,
            min_interactions: 1,
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_entity_network_pulse_entities__entity_id__network_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/entities/entity_id/network")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getEntityNetworkPulseEntitiesEntityIdNetworkGet("entity_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_entity_network_pg_pulse_entities__entity_id__network_pg_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/entities/entity_id/network/pg")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getEntityNetworkPgPulseEntitiesEntityIdNetworkPgGet("entity_id", {
            depth: 1,
            min_interactions: 1,
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_entity_network_pg_pulse_entities__entity_id__network_pg_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/entities/entity_id/network/pg")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getEntityNetworkPgPulseEntitiesEntityIdNetworkPgGet("entity_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_entity_details_pulse_entities__entity_type___entity_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/entities/entity_type/entity_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getEntityDetailsPulseEntitiesEntityTypeEntityIdGet("entity_type", "entity_id", {
            include_activities: true,
            time_range: "time_range",
            current_state: true,
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_entity_details_pulse_entities__entity_type___entity_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/entities/entity_type/entity_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getEntityDetailsPulseEntitiesEntityTypeEntityIdGet("entity_type", "entity_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_schemas_pulse_schemas_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            ok: true,
            objects: { key: "value" },
            activities: {
                key: {
                    title: "title",
                    icon: "icon",
                    applies_to: ["applies_to"],
                    primary_object: "primary_object",
                    properties: { key: "value" },
                    relationships: { key: { key: "value" } },
                    quick_action: true,
                    context_hints: { key: "value" },
                },
            },
            activity_rules: { key: { key: ["value"] } },
        };
        server.mockEndpoint().get("/pulse/schemas").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getSchemasPulseSchemasGet();
        expect(response).toEqual({
            ok: true,
            objects: {
                key: "value",
            },
            activities: {
                key: {
                    title: "title",
                    icon: "icon",
                    applies_to: ["applies_to"],
                    primary_object: "primary_object",
                    properties: {
                        key: "value",
                    },
                    relationships: {
                        key: {
                            key: "value",
                        },
                    },
                    quick_action: true,
                    context_hints: {
                        key: "value",
                    },
                },
            },
            activity_rules: {
                key: {
                    key: ["value"],
                },
            },
        });
    });

    test("search_activities_pulse_search_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/search")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.searchActivitiesPulseSearchPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("search_activities_pulse_search_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { query: undefined, search_type: undefined, filters: undefined, limit: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/search")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.searchActivitiesPulseSearchPost({
                query: undefined,
                search_type: undefined,
                filters: undefined,
                limit: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("search_entities_pulse_search_entities_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { query: "query" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/search/entities")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.searchEntitiesPulseSearchEntitiesPost({
            query: "query",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("search_entities_pulse_search_entities_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            query: "query",
            entity_ids: undefined,
            entity_types: undefined,
            mode: undefined,
            return_format: undefined,
            limit: undefined,
            similarity_threshold: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/search/entities")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.searchEntitiesPulseSearchEntitiesPost({
                query: "query",
                entity_ids: undefined,
                entity_types: undefined,
                mode: undefined,
                return_format: undefined,
                limit: undefined,
                similarity_threshold: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update_search_indexes_pulse_search_update_indexes_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/search/update-indexes")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateSearchIndexesPulseSearchUpdateIndexesPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_distinct_values_pulse_search_distinct__field__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/search/distinct/field")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getDistinctValuesPulseSearchDistinctFieldGet("field");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_distinct_values_pulse_search_distinct__field__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/search/distinct/field")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getDistinctValuesPulseSearchDistinctFieldGet("field");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("query_builder_pulse_query_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.queryBuilderPulseQueryPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("query_builder_pulse_query_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            limit: undefined,
            offset: undefined,
            text_query: undefined,
            time_range_start: undefined,
            time_range_end: undefined,
            last_hours: undefined,
            last_days: undefined,
            agent_types: undefined,
            agent_ids: undefined,
            object_types: undefined,
            object_ids: undefined,
            action_types: undefined,
            action_statuses: undefined,
            specific_actions: undefined,
            tags: undefined,
            exclude_tags: undefined,
            tag_mode: undefined,
            min_duration_minutes: undefined,
            max_duration_minutes: undefined,
            customer_id: undefined,
            team_name: undefined,
            deal_stages: undefined,
            revenue_impact: undefined,
            churn_risk: undefined,
            escalation_level: undefined,
            trace_id: undefined,
            triggered_by: undefined,
            sort_by: undefined,
            sort_direction: undefined,
            count_only: undefined,
            explain: undefined,
            aggregate: undefined,
            group_by: undefined,
            group_by_tag_prefix: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/query")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.queryBuilderPulseQueryPost({
                limit: undefined,
                offset: undefined,
                text_query: undefined,
                time_range_start: undefined,
                time_range_end: undefined,
                last_hours: undefined,
                last_days: undefined,
                agent_types: undefined,
                agent_ids: undefined,
                object_types: undefined,
                object_ids: undefined,
                action_types: undefined,
                action_statuses: undefined,
                specific_actions: undefined,
                tags: undefined,
                exclude_tags: undefined,
                tag_mode: undefined,
                min_duration_minutes: undefined,
                max_duration_minutes: undefined,
                customer_id: undefined,
                team_name: undefined,
                deal_stages: undefined,
                revenue_impact: undefined,
                churn_risk: undefined,
                escalation_level: undefined,
                trace_id: undefined,
                triggered_by: undefined,
                sort_by: undefined,
                sort_direction: undefined,
                count_only: undefined,
                explain: undefined,
                aggregate: undefined,
                group_by: undefined,
                group_by_tag_prefix: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("query_builder_schema_pulse_query_schema_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/query/schema")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.queryBuilderSchemaPulseQuerySchemaGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_pulse_files_pulse_files_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/pulse/files").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getPulseFilesPulseFilesGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("download_pulse_file_pulse_files__file_name__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/files/file_name")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.downloadPulseFilePulseFilesFileNameGet("file_name");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("download_pulse_file_pulse_files__file_name__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/files/file_name")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.downloadPulseFilePulseFilesFileNameGet("file_name");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("delete_pulse_file_pulse_files__file_name__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/pulse/files/file_name")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.deletePulseFilePulseFilesFileNameDelete("file_name");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("delete_pulse_file_pulse_files__file_name__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/pulse/files/file_name")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deletePulseFilePulseFilesFileNameDelete("file_name");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_file_chunks_pulse_files__file_name__chunks_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/files/file_name/chunks")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getFileChunksPulseFilesFileNameChunksGet("file_name");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_file_chunks_pulse_files__file_name__chunks_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/files/file_name/chunks")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getFileChunksPulseFilesFileNameChunksGet("file_name");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("generate_ai_suggestion_pulse_security_questionnaire_ai_suggest_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            question_id: "question_id",
            question_text: "question_text",
            category: "category",
            questionnaire_id: "questionnaire_id",
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/security-questionnaire/ai-suggest")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.generateAiSuggestionPulseSecurityQuestionnaireAiSuggestPost({
            question_id: "question_id",
            question_text: "question_text",
            category: "category",
            questionnaire_id: "questionnaire_id",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("generate_ai_suggestion_pulse_security_questionnaire_ai_suggest_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            question_id: "question_id",
            question_text: "question_text",
            category: "category",
            questionnaire_id: "questionnaire_id",
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/security-questionnaire/ai-suggest")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.generateAiSuggestionPulseSecurityQuestionnaireAiSuggestPost({
                question_id: "question_id",
                question_text: "question_text",
                category: "category",
                questionnaire_id: "questionnaire_id",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("generate_batch_suggestions_pulse_security_questionnaire_batch_suggest_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { question_ids: ["question_ids"], questionnaire_id: "questionnaire_id" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/pulse/security-questionnaire/batch-suggest")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.generateBatchSuggestionsPulseSecurityQuestionnaireBatchSuggestPost({
            question_ids: ["question_ids"],
            questionnaire_id: "questionnaire_id",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("generate_batch_suggestions_pulse_security_questionnaire_batch_suggest_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { question_ids: ["question_ids", "question_ids"], questionnaire_id: "questionnaire_id" };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/pulse/security-questionnaire/batch-suggest")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.generateBatchSuggestionsPulseSecurityQuestionnaireBatchSuggestPost({
                question_ids: ["question_ids", "question_ids"],
                questionnaire_id: "questionnaire_id",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update_questionnaire_files_pulse_security_questionnaire__questionnaire_id__files_put (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { file_ids: ["file_ids"] };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .put("/pulse/security-questionnaire/questionnaire_id/files")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateQuestionnaireFilesPulseSecurityQuestionnaireQuestionnaireIdFilesPut(
            "questionnaire_id",
            {
                file_ids: ["file_ids"],
            },
        );
        expect(response).toEqual({
            key: "value",
        });
    });

    test("update_questionnaire_files_pulse_security_questionnaire__questionnaire_id__files_put (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { file_ids: ["file_ids", "file_ids"] };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .put("/pulse/security-questionnaire/questionnaire_id/files")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.updateQuestionnaireFilesPulseSecurityQuestionnaireQuestionnaireIdFilesPut(
                "questionnaire_id",
                {
                    file_ids: ["file_ids", "file_ids"],
                },
            );
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_questionnaire_with_questions_pulse_security_questionnaire__questionnaire_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/pulse/security-questionnaire/questionnaire_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response =
            await client.getQuestionnaireWithQuestionsPulseSecurityQuestionnaireQuestionnaireIdGet("questionnaire_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_questionnaire_with_questions_pulse_security_questionnaire__questionnaire_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/pulse/security-questionnaire/questionnaire_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getQuestionnaireWithQuestionsPulseSecurityQuestionnaireQuestionnaireIdGet(
                "questionnaire_id",
            );
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("seed_agents_onboarding_seed_agents_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/onboarding/seed-agents")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.seedAgentsOnboardingSeedAgentsPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("send_followup_emails_onboarding_followup_emails_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { data: { ok: true, msg: "msg" } };
        server
            .mockEndpoint()
            .post("/onboarding/followup-emails")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.sendFollowupEmailsOnboardingFollowupEmailsPost();
        expect(response).toEqual({
            data: {
                ok: true,
                msg: "msg",
            },
        });
    });

    test("send_followup_emails_onboarding_followup_emails_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/onboarding/followup-emails")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.sendFollowupEmailsOnboardingFollowupEmailsPost(undefined);
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("find_me_me_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                id: "id",
                doc_type: "user",
                created_by: { type: "organization", id: "id" },
                updated_by: { type: "organization", id: "id" },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                first_name: "first_name",
                last_name: "last_name",
                email_address: "email_address",
                inbox_welcome_message_sent: true,
                consent: { key: true },
                use_cases: ["use_cases"],
                lead_id: "lead_id",
                organizations: { key: { favorites: undefined } },
                favorites: [{ id: "id", type: "type" }],
            },
        };
        server.mockEndpoint().get("/me").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.findMeMeGet();
        expect(response).toEqual({
            data: {
                id: "id",
                doc_type: "user",
                created_by: {
                    type: "organization",
                    id: "id",
                },
                updated_by: {
                    type: "organization",
                    id: "id",
                },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                first_name: "first_name",
                last_name: "last_name",
                email_address: "email_address",
                inbox_welcome_message_sent: true,
                consent: {
                    key: true,
                },
                use_cases: ["use_cases"],
                lead_id: "lead_id",
                organizations: {
                    key: {
                        favorites: undefined,
                    },
                },
                favorites: [
                    {
                        id: "id",
                        type: "type",
                    },
                ],
            },
        });
    });

    test("update_me_me_put (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            data: {
                id: "id",
                doc_type: "user",
                created_by: { type: "organization", id: "id" },
                updated_by: { type: "organization", id: "id" },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                first_name: "first_name",
                last_name: "last_name",
                email_address: "email_address",
                inbox_welcome_message_sent: true,
                consent: { key: true },
                use_cases: ["use_cases"],
                lead_id: "lead_id",
                organizations: { key: { favorites: undefined } },
                favorites: [{ id: "id", type: "type" }],
            },
        };
        server
            .mockEndpoint()
            .put("/me")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateMeMePut();
        expect(response).toEqual({
            data: {
                id: "id",
                doc_type: "user",
                created_by: {
                    type: "organization",
                    id: "id",
                },
                updated_by: {
                    type: "organization",
                    id: "id",
                },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                first_name: "first_name",
                last_name: "last_name",
                email_address: "email_address",
                inbox_welcome_message_sent: true,
                consent: {
                    key: true,
                },
                use_cases: ["use_cases"],
                lead_id: "lead_id",
                organizations: {
                    key: {
                        favorites: undefined,
                    },
                },
                favorites: [
                    {
                        id: "id",
                        type: "type",
                    },
                ],
            },
        });
    });

    test("update_me_me_put (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { favorites: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .put("/me")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.updateMeMePut({
                favorites: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("find_all_scout_hooks_hooks_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            hooks: [
                {
                    id: "id",
                    doc_type: "scout_hook",
                    created_by: { type: "organization", id: "id" },
                    updated_by: { type: "organization", id: "id" },
                    created_at: "2024-01-15T09:30:00Z",
                    updated_at: "2024-01-15T09:30:00Z",
                    is_seed: true,
                    hook_config: { type: "http", target_url: "target_url" },
                    name: "name",
                    description: "description",
                    metadata: { key: "value" },
                    parent: "parent",
                    triggering_events: [{ discriminator: undefined }],
                },
            ],
        };
        server.mockEndpoint().get("/hooks").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.findAllScoutHooksHooksGet();
        expect(response).toEqual({
            hooks: [
                {
                    id: "id",
                    doc_type: "scout_hook",
                    created_by: {
                        type: "organization",
                        id: "id",
                    },
                    updated_by: {
                        type: "organization",
                        id: "id",
                    },
                    created_at: "2024-01-15T09:30:00Z",
                    updated_at: "2024-01-15T09:30:00Z",
                    is_seed: true,
                    hook_config: {
                        type: "http",
                        target_url: "target_url",
                    },
                    name: "name",
                    description: "description",
                    metadata: {
                        key: "value",
                    },
                    parent: "parent",
                    triggering_events: [
                        {
                            discriminator: undefined,
                        },
                    ],
                },
            ],
        });
    });

    test("create_scout_hook_hooks_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            hook: {
                id: "id",
                doc_type: "scout_hook",
                created_by: { type: "organization", id: "id" },
                updated_by: { type: "organization", id: "id" },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                hook_config: { type: "http", target_url: "target_url" },
                name: "name",
                description: "description",
                metadata: { key: "value" },
                parent: "parent",
                triggering_events: [{ discriminator: undefined }],
            },
        };
        server
            .mockEndpoint()
            .post("/hooks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createScoutHookHooksPost({});
        expect(response).toEqual({
            hook: {
                id: "id",
                doc_type: "scout_hook",
                created_by: {
                    type: "organization",
                    id: "id",
                },
                updated_by: {
                    type: "organization",
                    id: "id",
                },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                hook_config: {
                    type: "http",
                    target_url: "target_url",
                },
                name: "name",
                description: "description",
                metadata: {
                    key: "value",
                },
                parent: "parent",
                triggering_events: [
                    {
                        discriminator: undefined,
                    },
                ],
            },
        });
    });

    test("create_scout_hook_hooks_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            hook_config: undefined,
            name: undefined,
            description: undefined,
            metadata: undefined,
            triggering_events: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/hooks")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createScoutHookHooksPost({
                hook_config: undefined,
                name: undefined,
                description: undefined,
                metadata: undefined,
                triggering_events: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update_scout_hook_hooks__hook_id__put (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = {
            hook: {
                id: "id",
                doc_type: "scout_hook",
                created_by: { type: "organization", id: "id" },
                updated_by: { type: "organization", id: "id" },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                hook_config: { type: "http", target_url: "target_url" },
                name: "name",
                description: "description",
                metadata: { key: "value" },
                parent: "parent",
                triggering_events: [{ discriminator: undefined }],
            },
        };
        server
            .mockEndpoint()
            .put("/hooks/hook_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateScoutHookHooksHookIdPut("hook_id", {});
        expect(response).toEqual({
            hook: {
                id: "id",
                doc_type: "scout_hook",
                created_by: {
                    type: "organization",
                    id: "id",
                },
                updated_by: {
                    type: "organization",
                    id: "id",
                },
                created_at: "2024-01-15T09:30:00Z",
                updated_at: "2024-01-15T09:30:00Z",
                is_seed: true,
                hook_config: {
                    type: "http",
                    target_url: "target_url",
                },
                name: "name",
                description: "description",
                metadata: {
                    key: "value",
                },
                parent: "parent",
                triggering_events: [
                    {
                        discriminator: undefined,
                    },
                ],
            },
        });
    });

    test("update_scout_hook_hooks__hook_id__put (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            hook_config: undefined,
            name: undefined,
            description: undefined,
            metadata: undefined,
            triggering_events: undefined,
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .put("/hooks/hook_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.updateScoutHookHooksHookIdPut("hook_id", {
                hook_config: undefined,
                name: undefined,
                description: undefined,
                metadata: undefined,
                triggering_events: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("remove_scout_hook_hooks__hook_id__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().delete("/hooks/hook_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.removeScoutHookHooksHookIdDelete("hook_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("remove_scout_hook_hooks__hook_id__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().delete("/hooks/hook_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.removeScoutHookHooksHookIdDelete("hook_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("rotate_api_keys_organization_rotate_keys_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/organization/rotate-keys")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.rotateApiKeysOrganizationRotateKeysPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("rotate_api_keys_organization_rotate_keys_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { confirm: undefined, grace_period_hours: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/organization/rotate-keys")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.rotateApiKeysOrganizationRotateKeysPost({
                confirm: undefined,
                grace_period_hours: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_tags_tags_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { tags: [{ id: "id", name: "name", description: "description", active: true }] };
        server.mockEndpoint().get("/tags").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.listTagsTagsGet();
        expect(response).toEqual({
            tags: [
                {
                    id: "id",
                    name: "name",
                    description: "description",
                    active: true,
                },
            ],
        });
    });

    test("create_tag_tags_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name" };
        const rawResponseBody = {
            ok: true,
            data: { id: "id", name: "name", description: "description", active: true },
        };
        server
            .mockEndpoint()
            .post("/tags")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createTagTagsPost({
            name: "name",
        });
        expect(response).toEqual({
            ok: true,
            data: {
                id: "id",
                name: "name",
                description: "description",
                active: true,
            },
        });
    });

    test("create_tag_tags_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: "name", description: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/tags")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createTagTagsPost({
                name: "name",
                description: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_tag_tags__tag_id__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { id: "id", name: "name", description: "description", active: true };
        server.mockEndpoint().get("/tags/tag_id").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getTagTagsTagIdGet("tag_id");
        expect(response).toEqual({
            id: "id",
            name: "name",
            description: "description",
            active: true,
        });
    });

    test("get_tag_tags__tag_id__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/tags/tag_id").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getTagTagsTagIdGet("tag_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("update_tag_tags__tag_id__put (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { ok: true };
        server
            .mockEndpoint()
            .put("/tags/tag_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.updateTagTagsTagIdPut("tag_id");
        expect(response).toEqual({
            ok: true,
        });
    });

    test("update_tag_tags__tag_id__put (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { name: undefined, description: undefined, active: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .put("/tags/tag_id")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.updateTagTagsTagIdPut("tag_id", {
                name: undefined,
                description: undefined,
                active: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_tools_tools_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            available: [
                {
                    tool_name: "tool_name",
                    tool_cname: "tool_cname",
                    group: "group",
                    description: "description",
                    icon_url: "icon_url",
                    input_schema: { key: "value" },
                    labels: ["labels"],
                },
            ],
            unavailable: [
                {
                    tool_name: "tool_name",
                    tool_cname: "tool_cname",
                    group: "group",
                    description: "description",
                    icon_url: "icon_url",
                    input_schema: { key: "value" },
                    labels: ["labels"],
                },
            ],
        };
        server.mockEndpoint().get("/tools").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.listToolsToolsGet();
        expect(response).toEqual({
            available: [
                {
                    tool_name: "tool_name",
                    tool_cname: "tool_cname",
                    group: "group",
                    description: "description",
                    icon_url: "icon_url",
                    input_schema: {
                        key: "value",
                    },
                    labels: ["labels"],
                },
            ],
            unavailable: [
                {
                    tool_name: "tool_name",
                    tool_cname: "tool_cname",
                    group: "group",
                    description: "description",
                    icon_url: "icon_url",
                    input_schema: {
                        key: "value",
                    },
                    labels: ["labels"],
                },
            ],
        });
    });

    test("get_tool_tools__tool_name__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            tool_name: "tool_name",
            tool_cname: "tool_cname",
            group: "group",
            description: "description",
            icon_url: "icon_url",
            input_schema: { key: "value" },
            labels: ["labels"],
        };
        server.mockEndpoint().get("/tools/tool_name").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getToolToolsToolNameGet("tool_name");
        expect(response).toEqual({
            tool_name: "tool_name",
            tool_cname: "tool_cname",
            group: "group",
            description: "description",
            icon_url: "icon_url",
            input_schema: {
                key: "value",
            },
            labels: ["labels"],
        });
    });

    test("get_tool_tools__tool_name__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server.mockEndpoint().get("/tools/tool_name").respondWith().statusCode(422).jsonBody(rawResponseBody).build();

        await expect(async () => {
            return await client.getToolToolsToolNameGet("tool_name");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("execute_tool_tools__tool_name__execute_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {};
        const rawResponseBody = { success: true, result: { key: "value" }, error: "error" };
        server
            .mockEndpoint()
            .post("/tools/tool_name/execute")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.executeToolToolsToolNameExecutePost("tool_name");
        expect(response).toEqual({
            success: true,
            result: {
                key: "value",
            },
            error: "error",
        });
    });

    test("execute_tool_tools__tool_name__execute_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { input_data: undefined };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/tools/tool_name/execute")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.executeToolToolsToolNameExecutePost("tool_name", {
                input_data: undefined,
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("interact_handler_world__agent_id___session_id___interact_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { messages: [{ content: "content" }] };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/world/agent_id/session_id/_interact")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.interactHandlerWorldAgentIdSessionIdInteractPost("agent_id", "session_id", {
            messages: [
                {
                    content: "content",
                },
            ],
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("interact_handler_world__agent_id___session_id___interact_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { messages: [{ content: "content" }, { content: "content" }] };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/world/agent_id/session_id/_interact")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.interactHandlerWorldAgentIdSessionIdInteractPost("agent_id", "session_id", {
                messages: [
                    {
                        content: "content",
                    },
                    {
                        content: "content",
                    },
                ],
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("interact_handler_world__agent_id___interact_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { messages: [{ content: "content" }] };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/world/agent_id/_interact")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.interactHandlerWorldAgentIdInteractPost("agent_id", {
            session_id: "session_id",
            body: {
                messages: [
                    {
                        content: "content",
                    },
                ],
            },
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("interact_handler_world__agent_id___interact_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { messages: [{ content: "content" }, { content: "content" }] };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/world/agent_id/_interact")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.interactHandlerWorldAgentIdInteractPost("agent_id", {
                body: {
                    messages: [
                        {
                            content: "content",
                        },
                        {
                            content: "content",
                        },
                    ],
                },
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("list_agents_agents_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/agents").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.listAgentsAgentsGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_active_agent_agents__agent_id__active_get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/agents/agent_id/active")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getActiveAgentAgentsAgentIdActiveGet("agent_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_active_agent_agents__agent_id__active_get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/agents/agent_id/active")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getActiveAgentAgentsAgentIdActiveGet("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("get_tools_agents_tools_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = {
            data: {
                available: [
                    {
                        tool_name: "tool_name",
                        tool_cname: "tool_cname",
                        group: undefined,
                        description: undefined,
                        icon_url: undefined,
                    },
                ],
                unavailable: [
                    {
                        tool_name: "tool_name",
                        tool_cname: "tool_cname",
                        group: undefined,
                        description: undefined,
                        icon_url: undefined,
                    },
                ],
            },
        };
        server.mockEndpoint().get("/agents/tools").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getToolsAgentsToolsGet();
        expect(response).toEqual({
            data: {
                available: [
                    {
                        tool_name: "tool_name",
                        tool_cname: "tool_cname",
                        group: undefined,
                        description: undefined,
                        icon_url: undefined,
                    },
                ],
                unavailable: [
                    {
                        tool_name: "tool_name",
                        tool_cname: "tool_cname",
                        group: undefined,
                        description: undefined,
                        icon_url: undefined,
                    },
                ],
            },
        });
    });

    test("delete_agent_agents__agent_id__delete (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .delete("/agents/agent_id")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.deleteAgentAgentsAgentIdDelete("agent_id");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("delete_agent_agents__agent_id__delete (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .delete("/agents/agent_id")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.deleteAgentAgentsAgentIdDelete("agent_id");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("expire_blobs__expire_blobs_post", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().post("/_expire_blobs").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.expireBlobsExpireBlobsPost();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_drive_drive_get", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server.mockEndpoint().get("/drive").respondWith().statusCode(200).jsonBody(rawResponseBody).build();

        const response = await client.getDriveDriveGet();
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_drive_file_drive_files__file_name__get (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .get("/drive/files/file_name")
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.getDriveFileDriveFilesFileNameGet("file_name");
        expect(response).toEqual({
            key: "value",
        });
    });

    test("get_drive_file_drive_files__file_name__get (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });

        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .get("/drive/files/file_name")
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.getDriveFileDriveFilesFileNameGet("file_name");
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("create_drive_crawl_drive_crawls_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { source_sync_settings: { source_archetype_id: "com.google.drive" }, url: "url" };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/drive/crawls")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.createDriveCrawlDriveCrawlsPost({
            source_sync_settings: {
                source_archetype_id: "com.google.drive",
            },
            url: "url",
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("create_drive_crawl_drive_crawls_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            source_sync_settings: { source_archetype_id: "com.google.drive" },
            schedule: undefined,
            url: "url",
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/drive/crawls")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.createDriveCrawlDriveCrawlsPost({
                source_sync_settings: {
                    source_archetype_id: "com.google.drive",
                },
                schedule: undefined,
                url: "url",
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("grant_access_drive_grant_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            agent_ids: ["agent_ids"],
            resources: [{ resource_id: "resource_id", resource_type: "tables" }],
        };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/drive/grant")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.grantAccessDriveGrantPost({
            agent_ids: ["agent_ids"],
            resources: [
                {
                    resource_id: "resource_id",
                    resource_type: "tables",
                },
            ],
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("grant_access_drive_grant_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            agent_ids: ["agent_ids", "agent_ids"],
            resources: [
                { resource_id: "resource_id", resource_type: "tables" },
                { resource_id: "resource_id", resource_type: "tables" },
            ],
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/drive/grant")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.grantAccessDriveGrantPost({
                agent_ids: ["agent_ids", "agent_ids"],
                resources: [
                    {
                        resource_id: "resource_id",
                        resource_type: "tables",
                    },
                    {
                        resource_id: "resource_id",
                        resource_type: "tables",
                    },
                ],
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });

    test("revoke_access_drive_revoke_post (1)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = { agent_ids: ["agent_ids"], resource_ids: ["resource_ids"] };
        const rawResponseBody = { key: "value" };
        server
            .mockEndpoint()
            .post("/drive/revoke")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(200)
            .jsonBody(rawResponseBody)
            .build();

        const response = await client.revokeAccessDriveRevokePost({
            agent_ids: ["agent_ids"],
            resource_ids: ["resource_ids"],
        });
        expect(response).toEqual({
            key: "value",
        });
    });

    test("revoke_access_drive_revoke_post (2)", async () => {
        const server = mockServerPool.createServer();
        const client = new ScoutClient({ apiKey: "test", environment: server.baseUrl });
        const rawRequestBody = {
            agent_ids: ["agent_ids", "agent_ids"],
            resource_ids: ["resource_ids", "resource_ids"],
        };
        const rawResponseBody = { detail: undefined };
        server
            .mockEndpoint()
            .post("/drive/revoke")
            .jsonBody(rawRequestBody)
            .respondWith()
            .statusCode(422)
            .jsonBody(rawResponseBody)
            .build();

        await expect(async () => {
            return await client.revokeAccessDriveRevokePost({
                agent_ids: ["agent_ids", "agent_ids"],
                resource_ids: ["resource_ids", "resource_ids"],
            });
        }).rejects.toThrow(Scout.UnprocessableEntityError);
    });
});
